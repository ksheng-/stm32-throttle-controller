%% $RCSfile: USART_Send.tlc,v $
%% $Revision: 2.0 $
%% $Date: 2014/06/06 $
%%
%% Abstract: USART Send
%%    STM32 Send string to selected USART
%%    Generated code is based on STM32 HAL Library files.
%%
%% Copyright 1990-2009 The MathWorks, Inc.
%assign CodeFormat = "Embedded-C"
%implements USART_Send "C"



%if !EXISTS(::CreateUSART_Send)
    %assign ::CreateUSART_Send  = TLC_TRUE
%endif

%if !EXISTS(::InsertInitHeader)
    %assign ::InsertInitHeader  = TLC_TRUE
%endif
%if !EXISTS(::InsertIncludes)
    %assign ::InsertIncludes  = TLC_TRUE
%endif 
%if !EXISTS(::StdioIncludes)
    %assign ::StdioIncludes  = TLC_TRUE
%endif 

%if !EXISTS(::InsertTxUSART)
    %assign ::InsertTxUSART  = TLC_TRUE
%endif 
%if !EXISTS(::InsertIncludesToUSART)
    %assign ::InsertIncludesToUSART  = TLC_TRUE
%endif 
%if !EXISTS(::InsertIncludesFromUSART)
    %assign ::InsertIncludesFromUSART  = TLC_TRUE
%endif 
%if !EXISTS(::InsertUSARTCallback)
    %assign ::InsertUSARTCallback  = TLC_TRUE
%endif 
%if !EXISTS(::InsertUARTCallback)
    %assign ::InsertUARTCallback  = TLC_TRUE
%endif 


    %assign ::CreateUSART_Send  = TLC_TRUE

%trace CreateUSART_Send  %<CreateUSART_Send>

%% Create function for USART Send:
%if EXISTS(CreateUSART_Send) && (CreateUSART_Send == TLC_TRUE)

    %%assign ::CreateUSART_Send = TLC_FALSE

%% Code for system initialization:
    %function Start(block,system) Output
        %assign USART_name =  SFcnParamSettings.USART_name
		%% Initialization is done once only per USART
		%if !EXISTS(::%<USART_name>_TX_START)
			%assign ::%<USART_name>_TX_START  = TLC_TRUE
			%openfile USART_Buf
			/* %<USART_name> initialization for send*/
			%<USART_name>_Tx_Initialization();
			%closefile USART_Buf
			%<LibMdlStartCustomCode(USART_Buf,"execution")>;
		%endif 		
    %endfunction	
	
	
%% Code for USART SEND configuration call:
    %function BlockInstanceSetup(block, system) void
        %assign SrcBaseName = LibGetMdlSrcBaseName()
        %assign modelH      = LibCreateSourceFile("Header", "Simulink", SrcBaseName)
        %assign modelC      = LibCreateSourceFile("Source", "Simulink", SrcBaseName)		
        %%model_USART.h and model_USART.c files
        %assign SrcBaseName_USART = "%<SrcBaseName>_USART"
        %assign modelH_USART      = LibCreateSourceFile("Header", "Simulink", SrcBaseName_USART)
        %assign modelC_USART      = LibCreateSourceFile("Source", "Simulink", SrcBaseName_USART)
%%Include model.h to model_USART.c 
        %if EXISTS(::InsertIncludesToUSART) && (::InsertIncludesToUSART == TLC_TRUE)
            %assign ::InsertIncludesToUSART    = TLC_FALSE		
            %openfile USART_Buf
				#include "%<SrcBaseName>.h"
				#include "%<SrcBaseName_USART>.h"
            %closefile USART_Buf
            %<LibSetSourceFileSection(modelC_USART,"Includes",USART_Buf)>
        %endif
%%AND Include model_USART.h to model.c
        %if EXISTS(::InsertIncludesFromUSART) && (::InsertIncludesFromUSART == TLC_TRUE)
            %assign ::InsertIncludesFromUSART    = TLC_FALSE		
            %openfile USART_Buf
				#include "%<SrcBaseName_USART>.h"
            %closefile USART_Buf
            %<LibSetSourceFileSection(modelH,"Includes",USART_Buf)>			
			
            %openfile USART_Buf
				//RP MODIF #include "%<SrcBaseName>_STM32.h"
				#include "STM32_Config.h"
            %closefile USART_Buf
            %<LibSetSourceFileSection(modelH_USART,"Includes",USART_Buf)>			
        %endif		
        %assign USART_name =  SFcnParamSettings.USART_name		
		%assign Buff_size = SFcnParamSettings.Buff_size
		%assign nbUsart = SFcnParamSettings.nbUsart
        %assign usartMode =  SFcnParamSettings.usartMode		
        %assign usartDma_Rx =  SFcnParamSettings.usartDma_Rx		
        %assign usartDma_Tx =  SFcnParamSettings.usartDma_Tx		
        %assign usartIt =  SFcnParamSettings.usartIt
		%assign usartNum = IDNUM("%<USART_name>")[1]


		%if (ISEQUAL(usartMode, "Synchronous"))
        %if EXISTS(::InsertUSARTCallback) && (::InsertUSARTCallback == TLC_TRUE)
            %assign ::InsertUSARTCallback    = TLC_FALSE		
  		    %openfile USART_Buf
            /*******************************************************************************
            * Function Name  : HAL_USART_TxCpltCallback
            * Description    : Tx Transfer completed callbacks. 
            * Input          : USART handle
            *******************************************************************************/
            void HAL_USART_TxCpltCallback(USART_HandleTypeDef *husart)
            {
			%if(%<nbUsart> > 1)				
				uint16_t L_UsartHandleIdx = 0;/* Index to retreive USART data information */
    			struct USART_TxDataLinkTypeDef*   pL_USART_TxData = G_Usart_TxData[0]; /* Pt to the list of USART Tx data information */
				USART_HandleTypeDef*     pL_USART_Handler = (USART_HandleTypeDef*)G_Usart_TxHandler[0]; /* Pt to the list of USART Tx handler */
				for(L_UsartHandleIdx = 0;L_UsartHandleIdx < %<nbUsart>;L_UsartHandleIdx++) {
					pL_USART_Handler = (USART_HandleTypeDef*)G_Usart_TxHandler[L_UsartHandleIdx];
					if(pL_USART_Handler == husart) {
						pL_USART_TxData = G_Usart_TxData[L_UsartHandleIdx];
						break;
					}
				}
			%else
    			struct USART_TxDataLinkTypeDef*   pL_USART_TxData = G_Usart_TxData; /* Pt to USART data information */
				USART_HandleTypeDef*     pL_USART_Handler = (USART_HandleTypeDef*)G_Usart_TxHandler; /* Pt to USART handler */
			%endif
				if(pL_USART_Handler == husart) {
					pL_USART_TxData->txStatus = USART_TX_OK;   
                    pL_USART_TxData->pt_Tx_R +=  pL_USART_TxData->nbSent;            
                    if(pL_USART_TxData->pt_Tx_R >= pL_USART_TxData->pt_EndTx_Buff) {
                        pL_USART_TxData->pt_Tx_R = pL_USART_TxData->pt_StartTx_Buff;
                    }
                    if(pL_USART_TxData->txLock == 0) {
                        pL_USART_TxData->nb2Send -=  pL_USART_TxData->nbSent;
                    } else {
                        pL_USART_TxData->txLock = 2;
                    }
				}
			}			
            %closefile USART_Buf
			%<LibSetSourceFileSection(modelC_USART,"Functions",USART_Buf)>
		%endif	
		%else
        %if EXISTS(::InsertUARTCallback) && (::InsertUARTCallback == TLC_TRUE)
            %assign ::InsertUARTCallback    = TLC_FALSE		
  		    %openfile USART_Buf
            /*******************************************************************************
            * Function Name  : HAL_UART_TxCpltCallback
            * Description    : Tx Transfer completed callbacks. 
            * Input          : UART handle
            *******************************************************************************/
            void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
            {
			%if(%<nbUsart> > 1)				
				uint16_t L_UsartHandleIdx = 0;/* Index to retreive UART data information */
    			struct USART_TxDataLinkTypeDef*   pL_UART_TxData = G_Usart_TxData[0]; /* Pt to the list of UART Tx data information */
				UART_HandleTypeDef*     pL_UART_Handler = (UART_HandleTypeDef*)G_Usart_TxHandler[0]; /* Pt to the list of UART Tx handler */
				for(L_UsartHandleIdx = 0;L_UsartHandleIdx < %<nbUsart>;L_UsartHandleIdx++) {
					pL_UART_Handler = (UART_HandleTypeDef*)G_Usart_TxHandler[L_UsartHandleIdx];
					if(pL_UART_Handler == huart) {
						pL_UART_TxData = G_Usart_TxData[L_UsartHandleIdx];
						break;
					}
				}
			%else
    			struct USART_TxDataLinkTypeDef*   pL_UART_TxData = G_Usart_TxData; /* Pt to UART data information */
				UART_HandleTypeDef*     pL_UART_Handler = (UART_HandleTypeDef*)G_Usart_TxHandler; /* Pt to UART handler */
			%endif
				if(pL_UART_Handler == huart) {
					pL_UART_TxData->txStatus = USART_TX_OK;
                    pL_UART_TxData->pt_Tx_R +=  pL_UART_TxData->nbSent;            
                    if(pL_UART_TxData->pt_Tx_R >= pL_UART_TxData->pt_EndTx_Buff) {
                        pL_UART_TxData->pt_Tx_R = pL_UART_TxData->pt_StartTx_Buff;
                    }
                    if(pL_UART_TxData->txLock == 0) {
                        pL_UART_TxData->nb2Send -=  pL_UART_TxData->nbSent;
                    } else {
                        pL_UART_TxData->txLock = 2;
                    }
				}
			}		
            %closefile USART_Buf
			%<LibSetSourceFileSection(modelC_USART,"Functions",USART_Buf)>
		%endif	
		%endif

        %if EXISTS(::InsertTxUSART) && (::InsertTxUSART == TLC_TRUE)
            %assign ::InsertTxUSART    = TLC_FALSE		
            %openfile USART_Buf
			/** 
			* @brief USART Tx State structures definition  
			*/ 
			typedef enum
			{
			USART_TX_ON             = 0x00,    /*!< Tx usart communication start   */
			USART_TX_OK             = 0x01,    /*!< Tx usart communication terminated.*/
			USART_TX_OFF            = 0x02     /*!< Tx usart communication stop */      
			}USART_TxStatusTypeDef;
			/** 
			* @brief  USART data information
			*/ 
			struct USART_TxDataLinkTypeDef {
             uint16_t                nb2Send;       /*!< Nb of char to send*/
             uint16_t                nbSent;        /*!< Nb sent char*/
             uint16_t                nbMsgLost;     /*!< Nb lost msg (not enought space in ring buffer)*/
             uint16_t                buffSize;      /*!< Size of send ring buffer*/
             uint8_t*                pt_StartTx_Buff; /*!< point to ring buffer*/
             uint8_t*                pt_EndTx_Buff; /*!< point to end ring buffer*/
             uint8_t*                pt_Tx_W;       /*!< point to free space*/
             uint8_t*                pt_Tx_R;       /*!< point to char to send*/
             void     (* CopyDataFcn)(uint8_t* ptSrc, uint16_t DataLength, struct USART_TxDataLinkTypeDef* ptInfo);  
             void     (* SendDataFcn)(struct USART_TxDataLinkTypeDef* ptInfo);  
			 __IO USART_TxStatusTypeDef   txStatus;	    /*!< Usart send communication status.*/
             uint8_t                 txLock;        /*!< lock data access */
			};
           
			void     %<USART_name>_CopyDataFcn (uint8_t*, uint16_t , struct USART_TxDataLinkTypeDef* ); 
            void     %<USART_name>_SendDataFcn (struct USART_TxDataLinkTypeDef* );  
			uint32_t getBuffPtr(uint8_t*); /* Function prototype used from MATLAB script */             
            %closefile USART_Buf
            %<LibSetSourceFileSection(modelH_USART,"Defines",USART_Buf)>
           
  		    %openfile USART_Buf
 			%if (%<nbUsart> > 1)
			uint16_t               G_NbUsartTxConf = 0; /* Number of USART/UART configured for send*/
            /* Array of USART/UART send data information */
            struct USART_TxDataLinkTypeDef*   G_Usart_TxData[%<nbUsart>];
			void*     G_Usart_TxHandler[%<nbUsart>];
			%else
            struct USART_TxDataLinkTypeDef*   G_Usart_TxData;      /* Pointer to USART/UART send data information*/
			void*     G_Usart_TxHandler;   /* Pointer to USART/UART handler configured for send*/
			%endif
            %closefile USART_Buf
            %<LibSetSourceFileSection(modelC_USART,"Defines",USART_Buf)>	

		
  		    %openfile USART_Buf
            /*******************************************************************************
            * Function Name  : getBuffPtr
            * Description    : Return buffer address. This function is called from MATLAB script
			*                  using coder.ceval('getBuffPtr',coder.rref(buffer))
			*                  to get buffer address to send
            * Input          : buffPtr
            *******************************************************************************/
            uint32_t getBuffPtr(uint8_t* buffPtr)
            {
				return((uint32_t)buffPtr);
			}	
            %closefile USART_Buf
			%<LibSetSourceFileSection(modelC_USART,"Functions",USART_Buf)>		
		%endif
		
		%if !EXISTS(::%<USART_name>_InsertTxUSART)
			%assign ::%<USART_name>_InsertTxUSART  = TLC_TRUE		
		%openfile USART_Buf
        %if (ISEQUAL(usartIt, "on") == TLC_FALSE && ISEQUAL(usartDma_Tx, "on") == TLC_FALSE )
		/* %<USART_name> Tx polling timeout value. Number of Solver loop. (can be changed)*/
		uint32_t G_%<USART_name>_TxPollTimeOut = 10;
		%endif				
		%closefile USART_Buf
        %<LibSetSourceFileSection(modelC_USART,"Definitions",USART_Buf)>	

		%openfile USART_Buf
        %if (ISEQUAL(usartIt, "on") == TLC_FALSE && ISEQUAL(usartDma_Tx, "on") == TLC_FALSE )
		/* %<USART_name> Tx polling timeout value. Number of Solver loop. (can be changed)*/
		extern uint32_t G_%<USART_name>_TxPollTimeOut;
		%endif				
		%closefile USART_Buf
        %<LibSetSourceFileSection(modelH_USART,"Defines",USART_Buf)>	

		%openfile USART_Buf
		/* %<USART_name> ring data send buffer*/
		uint8_t G_%<USART_name>_TxDataBuffer[%<Buff_size>];	
    	/* %<USART_name> send data structure information*/
        struct USART_TxDataLinkTypeDef   %<USART_name>_TxDataLink;		
		%closefile USART_Buf
        %<LibSetSourceFileSection(modelC_USART,"Defines",USART_Buf)>	
		
%% Code for required USART external definition: in model_USART.c file
        %openfile USART_Buf
            /* %<USART_name> handler */
			%if (ISEQUAL(usartMode, "Synchronous"))
            extern USART_HandleTypeDef husart%<usartNum>;
            %%test for DMA handler
            %if (ISEQUAL(usartDma_Rx, "on"))
            extern DMA_HandleTypeDef hdma_usart%<usartNum>_rx;
            %endif
            %if (ISEQUAL(usartDma_Tx, "on"))
            extern DMA_HandleTypeDef hdma_usart%<usartNum>_tx;
            %endif
			%else
            extern UART_HandleTypeDef huart%<usartNum>;
            %%test for DMA handler
            %if (ISEQUAL(usartDma_Rx, "on"))
            extern DMA_HandleTypeDef hdma_uart%<usartNum>_rx;
            %endif
            %if (ISEQUAL(usartDma_Tx, "on"))
            extern DMA_HandleTypeDef hdma_uart%<usartNum>_tx;
            %endif
			%endif
			/* %<USART_name> send data structure information*/
			extern struct USART_TxDataLinkTypeDef   %<USART_name>_TxDataLink;		
			/* %<USART_name> data buffer send*/
			extern uint8_t G_%<USART_name>_TxDataBuffer[];							
        %closefile USART_Buf
        %<LibSetSourceFileSection(modelH_USART,"Defines",USART_Buf)>
        %endif

		%% Initialization is defined once only per USART
		%if !EXISTS(::%<USART_name>_TX_INIT)
			%assign ::%<USART_name>_TX_INIT  = TLC_TRUE
		
        %openfile USART_Buf
        /* %<USART_name>_Tx_Initialization prototyping */
        void %<USART_name>_Tx_Initialization(void);
        %closefile USART_Buf
        %<LibSetSourceFileSection(modelH_USART,"Defines",USART_Buf)>

        %openfile USART_Buf
        /*******************************************************************************
        * Function Name  : %<USART_name>_Tx_Initialization
        * Description    : Send Initialization of %<USART_name>
        * Input          : -
        *******************************************************************************/
        void %<USART_name>_Tx_Initialization(void)
        {
		%if(%<nbUsart> > 1)						
			/*Store %<USART_name> send data information and its handler */ 
			G_Usart_TxData[G_NbUsartTxConf] = &%<USART_name>_TxDataLink;
			%if (ISEQUAL(usartMode, "Synchronous"))
			G_Usart_TxHandler[G_NbUsartTxConf] = (void*)&husart%<usartNum>;
			%else
			G_Usart_TxHandler[G_NbUsartTxConf] = (void*)&huart%<usartNum>;
			%endif
			G_NbUsartTxConf++; /*Inc number of configured USART for send*/
		%else
			/*Store %<USART_name> send data information and its handler */ 
			G_Usart_TxData = &%<USART_name>_TxDataLink;
			%if (ISEQUAL(usartMode, "Synchronous"))
			G_Usart_TxHandler = (void*)&husart%<usartNum>;
			%else
			G_Usart_TxHandler = (void*)&huart%<usartNum>;
			%endif
		%endif
            /* Initialize ring buffer information */
            %<USART_name>_TxDataLink.nb2Send = 0;   
            %<USART_name>_TxDataLink.nbSent = 0;   
            %<USART_name>_TxDataLink.nbMsgLost = 0;   
            %<USART_name>_TxDataLink.buffSize = %<Buff_size>;
            %<USART_name>_TxDataLink.pt_StartTx_Buff = G_%<USART_name>_TxDataBuffer;
            %<USART_name>_TxDataLink.pt_EndTx_Buff = &G_%<USART_name>_TxDataBuffer[%<Buff_size>];
            %<USART_name>_TxDataLink.pt_Tx_W = G_%<USART_name>_TxDataBuffer;
            %<USART_name>_TxDataLink.pt_Tx_R = G_%<USART_name>_TxDataBuffer;
            %<USART_name>_TxDataLink.CopyDataFcn = %<USART_name>_CopyDataFcn;  
            %<USART_name>_TxDataLink.SendDataFcn = %<USART_name>_SendDataFcn;  
			%<USART_name>_TxDataLink.txStatus =  USART_TX_OFF;
            %<USART_name>_TxDataLink.txLock = 0;
        }  		
        %closefile USART_Buf
        %<LibSetSourceFileSection(modelC_USART,"Functions",USART_Buf)>

        %openfile USART_Buf
        /*******************************************************************************
        * Function Name  : %<USART_name>_CopyDataFcn
        * Description    : %<USART_name> copy msg to send to ring buffer (if possible)
        * Input          : pointer to data to send , lengh(number) of data to send and
        *                  ring buffer info
        *******************************************************************************/
        void  %<USART_name>_CopyDataFcn(uint8_t* ptSrc, uint16_t DataLength, struct USART_TxDataLinkTypeDef* ptInfo)
        {    
            uint16_t L_sizeMsg;
            uint16_t L_idx;
            /* Copy msg to send to ring buffer */
            L_sizeMsg = 0;
            for(L_idx=0;L_idx<DataLength;L_idx++){
                if((((uint32_t)ptInfo->pt_Tx_W == (uint32_t)ptInfo->pt_Tx_R)&&ptInfo->nb2Send!=0))
                    break; //Ring Buffer is full.                        
                *(char*)ptInfo->pt_Tx_W++ = *(char*)ptSrc++;
                L_sizeMsg++;
                if(ptInfo->pt_Tx_W == ptInfo->pt_Tx_R)
                    break; //Ring Buffer is full.  
                if(ptInfo->pt_Tx_W == ptInfo->pt_EndTx_Buff){
                    //Revolve buffer
                    ptInfo->pt_Tx_W = ptInfo->pt_StartTx_Buff;
                }
            }
            /* update nb of data to send */
            ptInfo->txLock = 1; //Access locked
            ptInfo->nb2Send += L_sizeMsg;
            if(ptInfo->txLock == 2) //If end of send interrupt mode arrived during last instruction
                ptInfo->nb2Send -=  ptInfo->nbSent;
            ptInfo->txLock = 0; //Unlock access 
            if(L_sizeMsg < DataLength)
                ptInfo->nbMsgLost++; //Message not all sent 

        }  		
        %closefile USART_Buf
        %<LibSetSourceFileSection(modelC_USART,"Functions",USART_Buf)>

        %openfile USART_Buf
        /*******************************************************************************
        * Function Name  : %<USART_name>_SendDataFcn
        * Description    : %<USART_name> Send ring buffer management
        * Input          : Ring buffer info
        *******************************************************************************/
        void  %<USART_name>_SendDataFcn(struct USART_TxDataLinkTypeDef* ptInfo)
        {    
             uint16_t L_sizeMsg;
            /* If USART is not already running and data to send */
            if(ptInfo->txStatus != USART_TX_ON && ptInfo->nb2Send) {
                ptInfo->txStatus = USART_TX_ON;
                L_sizeMsg = (uint32_t)ptInfo->pt_EndTx_Buff - (uint32_t)ptInfo->pt_Tx_R;
                /* Send all msg or end of ring buffer */
                if(ptInfo->nb2Send <= L_sizeMsg) {
                    ptInfo->nbSent = ptInfo->nb2Send;
        	%if (ISEQUAL(usartMode, "Synchronous"))
                %if (ISEQUAL(usartDma_Tx, "on"))
                    /* %<USART_name> DMA send mode*/
                    HAL_USART_Transmit_DMA(&husart%<usartNum>, ptInfo->pt_Tx_R, ptInfo->nb2Send);				
    			%elseif (ISEQUAL(usartIt, "on"))
        			/* %<USART_name> interrupt send mode*/
        			HAL_USART_Transmit_IT(&husart%<usartNum>, ptInfo->pt_Tx_R, ptInfo->nb2Send);
    			%else 
            		/* %<USART_name> pooling send mode*/
                	HAL_USART_Transmit(&husart%<usartNum>, ptInfo->pt_Tx_R, ptInfo->nb2Send, G_%<USART_name>_TxPollTimeOut);
					/* Update info. Always consider data has been sent*/
					ptInfo->txStatus = USART_TX_OK;   
                    ptInfo->pt_Tx_R +=  ptInfo->nbSent;            
                    if(ptInfo->pt_Tx_R >= ptInfo->pt_EndTx_Buff) {
                        ptInfo->pt_Tx_R = ptInfo->pt_StartTx_Buff;
                    }
                    ptInfo->nb2Send -=  ptInfo->nbSent;
    			%endif
       		%else
    			%if (ISEQUAL(usartDma_Tx, "on"))
        			/* %<USART_name> DMA send mode*/
        			HAL_UART_Transmit_DMA(&huart%<usartNum>, ptInfo->pt_Tx_R, ptInfo->nb2Send);				
    			%elseif (ISEQUAL(usartIt, "on"))
            		/* %<USART_name> interrupt send mode*/
                	HAL_UART_Transmit_IT(&huart%<usartNum>, ptInfo->pt_Tx_R, ptInfo->nb2Send);
    			%else 
                    /* %<USART_name> pooling send mode*/
        			HAL_UART_Transmit(&huart%<usartNum>, ptInfo->pt_Tx_R, ptInfo->nb2Send, G_%<USART_name>_TxPollTimeOut);
 					/* Update info. Always consider data has been sent*/
					ptInfo->txStatus = USART_TX_OK;   
                    ptInfo->pt_Tx_R +=  ptInfo->nbSent;            
                    if(ptInfo->pt_Tx_R >= ptInfo->pt_EndTx_Buff) {
                        ptInfo->pt_Tx_R = ptInfo->pt_StartTx_Buff;
                    }
                    ptInfo->nb2Send -=  ptInfo->nbSent;
   			%endif
            %endif
                } else {
                    ptInfo->nbSent = L_sizeMsg;
        	%if (ISEQUAL(usartMode, "Synchronous"))
                %if (ISEQUAL(usartDma_Tx, "on"))
                    /* %<USART_name> DMA send mode*/
                    HAL_USART_Transmit_DMA(&husart%<usartNum>, ptInfo->pt_Tx_R, L_sizeMsg);				
    			%elseif (ISEQUAL(usartIt, "on"))
        			/* %<USART_name> interrupt send mode*/
        			HAL_USART_Transmit_IT(&husart%<usartNum>, ptInfo->pt_Tx_R, L_sizeMsg);
    			%else 
            		/* %<USART_name> pooling send mode*/
                	HAL_USART_Transmit(&husart%<usartNum>, ptInfo->pt_Tx_R, L_sizeMsg, G_%<USART_name>_TxPollTimeOut);
 					/* Update info. Always consider data has been sent*/
					ptInfo->txStatus = USART_TX_OK;   
                    ptInfo->pt_Tx_R +=  ptInfo->nbSent;            
                    if(ptInfo->pt_Tx_R >= ptInfo->pt_EndTx_Buff) {
                        ptInfo->pt_Tx_R = ptInfo->pt_StartTx_Buff;
                    }
                    ptInfo->nb2Send -=  ptInfo->nbSent;
   			%endif
       		%else
    			%if (ISEQUAL(usartDma_Tx, "on"))
        			/* %<USART_name> DMA send mode*/
        			HAL_UART_Transmit_DMA(&huart%<usartNum>, ptInfo->pt_Tx_R, L_sizeMsg);				
    			%elseif (ISEQUAL(usartIt, "on"))
            		/* %<USART_name> interrupt send mode*/
                	HAL_UART_Transmit_IT(&huart%<usartNum>, ptInfo->pt_Tx_R, L_sizeMsg);
    			%else 
                    /* %<USART_name> pooling send mode*/
        			HAL_UART_Transmit(&huart%<usartNum>, ptInfo->pt_Tx_R, L_sizeMsg, G_%<USART_name>_TxPollTimeOut);
					/* Update info. Always consider data has been sent*/
					ptInfo->txStatus = USART_TX_OK;   
                    ptInfo->pt_Tx_R +=  ptInfo->nbSent;            
                    if(ptInfo->pt_Tx_R >= ptInfo->pt_EndTx_Buff) {
                        ptInfo->pt_Tx_R = ptInfo->pt_StartTx_Buff;
                    }
                    ptInfo->nb2Send -=  ptInfo->nbSent;
    			%endif
            %endif
                }
            }           
        }  		
        %closefile USART_Buf
        %<LibSetSourceFileSection(modelC_USART,"Functions",USART_Buf)>
		%endif


    %endfunction
%else
%% ERROR USART SEND INIT MUST BE CALLED ONCE ONLY 
   %trace ERROR USART INIT MUST BE CALLED ONCE ONLY 
%endif 

%% Function: Outputs ==========================================
%% Abstract:
%% USART_Send input value depending on pin config
%%
    %function Outputs(block, system) Output
		/* %<Type> Block: %<Name> */  
        %assign USART_name =  SFcnParamSettings.USART_name		
		%assign Buff_size = SFcnParamSettings.Buff_size
		%assign nbUsart = SFcnParamSettings.nbUsart
        %assign usartMode =  SFcnParamSettings.usartMode		
        %assign usartDma_Rx =  SFcnParamSettings.usartDma_Rx		
        %assign usartDma_Tx =  SFcnParamSettings.usartDma_Tx		
        %assign usartIt =  SFcnParamSettings.usartIt		
		%assign usartNum = IDNUM("%<USART_name>")[1]
		%%block Output 
		%assign NbSent = LibBlockOutputSignal(0, "", "", 0)
		%assign Nb2Send = LibBlockInputSignal(0, "", "", 0)
		%assign uAddr = LibBlockInputSignal(1, "", "", 0) 
		
%% 		%openfile USART_Buf
		if(%<Nb2Send> != 0)
		{
            /* Wait for end of current send data*/ 
            while(%<USART_name>_TxDataLink.txStatus == USART_TX_ON);
            /* Copy data to send */
            %<USART_name>_CopyDataFcn((uint8_t*)%<uAddr>, (uint16_t)%<Nb2Send>, &%<USART_name>_TxDataLink);
        }
%%		%closefile USART_Buf
%%        %<LibSystemOutputCustomCode(system,USART_Buf,"trailer")>	
%%        %<LibSystemOutputCustomCode(system,USART_Buf,"execution")>	

%%RP		%if !EXISTS(::%<USART_name>_InsertTxSendUSART)
        %assign ::%<USART_name>_InsertTxSendUSART  = TLC_TRUE
%%		%openfile USART_Buf

		%if (ISEQUAL(usartMode, "Synchronous"))
//RP_MODIF		if(husart%<usartNum>.State == HAL_USART_STATE_READY)
		if(%<USART_name>_TxDataLink.nb2Send)
		{
			%<NbSent> = 0;
            %<USART_name>_SendDataFcn(&%<USART_name>_TxDataLink);
		}
		%else
//RP_MODIF		if(huart%<usartNum>.State == HAL_UART_STATE_READY)
		if(%<USART_name>_TxDataLink.nb2Send)
		{
			%<NbSent> = 0;
            %<USART_name>_SendDataFcn(&%<USART_name>_TxDataLink);
		}
		%endif	

		if(%<USART_name>_TxDataLink.txStatus != USART_TX_ON){
            %<NbSent> = %<USART_name>_TxDataLink.nbSent;
		}
        %if (ISEQUAL(usartDma_Tx, "on"))
        %elseif(ISEQUAL(usartIt, "on"))
        %else
            %<USART_name>_TxDataLink.txStatus = USART_TX_OFF;
        %endif
%%		%closefile USART_Buf
%%RP        %<LibSystemOutputCustomCode(system,USART_Buf,"trailer")>	
%%        %<LibSystemOutputCustomCode(system,USART_Buf,"execution")>	
%%RP        %endif
	
   %endfunction

%% [EOF] USART_Send.tlc






