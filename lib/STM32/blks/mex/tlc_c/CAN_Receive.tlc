%% $RCSfile: CAN_Receive.tlc,v $
%% $Revision: 2.1 $
%% $Date: 2014/05/26 $
%%
%% Abstract: CAN Receive 
%%    Receive frame for selected CANx
%%    Generated code is based on STM32 HAL Library files.
%%
%% Copyright 1990-2009 The MathWorks, Inc.
%assign CodeFormat = "Embedded-C"
%implements CAN_Receive "C"


%%warning "---------->Start CAN_Receive"

%if !EXISTS(::CreateCAN_Receive)
    %assign ::CreateCAN_Receive  = TLC_TRUE
%endif

%if !EXISTS(::InsertIncludesToCAN)
    %assign ::InsertIncludesToCAN  = TLC_TRUE
%endif 

%if !EXISTS(::InsertIncludesFromCAN)
    %assign ::InsertIncludesFromCAN  = TLC_TRUE
%endif 



%assign CAN_name =  SFcnParamSettings.CAN_name
%if !EXISTS(::VarDef_%<CAN_name>)
    %assign ::VarDef_%<CAN_name>  = TLC_TRUE
%endif 

%if !EXISTS(::DataReady_%<CAN_name>)
    %assign ::DataReady_%<CAN_name>  = TLC_TRUE
%endif 


%if !EXISTS(::RxMessage_%<CAN_name>)
	%assign ::RxMessage_%<CAN_name>  = TLC_TRUE
%endif

%if !EXISTS(::SetRxMessage_%<CAN_name>)
	%assign ::SetRxMessage_%<CAN_name>  = TLC_TRUE
%endif

%assign ::CreateCAN_Receive  = TLC_TRUE

%trace CreateCAN_Receive  %<CreateCAN_Receive>


%% Create function for CAN Read:
%if EXISTS(CreateCAN_Receive) && (CreateCAN_Receive == TLC_TRUE)

    %%assign ::CreateCAN_Receive = TLC_FALSE

%% Code for system initialization:
    %function Start(block,system) Output
        %assign CAN_name =  SFcnParamSettings.CAN_name
		%if (ISEQUAL(CAN_name, "CAN"))
			%assign CANNum = ""
		%else
			%assign CANNum = IDNUM("%<CAN_name>")[1]
		%endif		

		%if EXISTS(::SetRxMessage_%<CAN_name>) && (::SetRxMessage_%<CAN_name> == TLC_TRUE)
			%assign ::SetRxMessage_%<CAN_name>  = TLC_FALSE		
		/* Set %<CAN_name> receive message buffer */
		hcan%<CANNum>.pRxMsg = &RxMessage_%<CAN_name>;
		%endif
    %endfunction


%% Code for CAN configuration call:
    %function BlockInstanceSetup(block, system) void
        %%model.c and model.h files
        %assign SrcBaseName = LibGetMdlSrcBaseName()
        %assign modelH      = LibCreateSourceFile("Header", "Simulink", SrcBaseName)
        %assign modelC      = LibCreateSourceFile("Source", "Simulink", SrcBaseName)
        %%model_CAN.h and model_CAN.c files
        %assign SrcBaseName_CAN = "%<SrcBaseName>_CAN"
        %assign modelH_CAN      = LibCreateSourceFile("Header", "Simulink", SrcBaseName_CAN)
        %assign modelC_CAN      = LibCreateSourceFile("Source", "Simulink", SrcBaseName_CAN)
%%Include model.h to model_CAN.c 
        %if EXISTS(::InsertIncludesToCAN) && (::InsertIncludesToCAN == TLC_TRUE)
            %assign ::InsertIncludesToCAN    = TLC_FALSE		
            %openfile CAN_Buf
				#include "%<SrcBaseName>.h"
				#include "%<SrcBaseName_CAN>.h"
            %closefile CAN_Buf
            %<LibSetSourceFileSection(modelC_CAN,"Includes",CAN_Buf)>
        %endif
%%AND Include model_CAN.h to model.c
        %if EXISTS(::InsertIncludesFromCAN) && (::InsertIncludesFromCAN == TLC_TRUE)
            %assign ::InsertIncludesFromCAN    = TLC_FALSE		
            %openfile CAN_Buf
				#include "%<SrcBaseName_CAN>.h"
            %closefile CAN_Buf
            %<LibSetSourceFileSection(modelH,"Includes",CAN_Buf)>
            
			%openfile CAN_Buf
				//RP MODIF #include "%<SrcBaseName>_STM32.h"
				#include "STM32_Config.h"
            %closefile CAN_Buf
            %<LibSetSourceFileSection(modelH_CAN,"Includes",CAN_Buf)>						
        %endif

%%Then build model_CAN.h and model_CAN.c
        %assign CAN_name =  SFcnParamSettings.CAN_name
        %assign CAN_Fifo =  SFcnParamSettings.CAN_Fifo
        %assign CAN_It =  SFcnParamSettings.CAN_It
        %assign CAN_Rcv_TimeOut =  SFcnParamSettings.CAN_Rcv_TimeOut
        %assign CAN_Mode =  SFcnParamSettings.CAN_Mode		
        %assign nbCAN =  SFcnParamSettings.nbCAN
		
%%warning "---------->CAN_name: %<CAN_name> nbCAN:%<nbCAN>"
		
		
%% Code for required CAN external definition: in model_CAN.c file
    %if (ISEQUAL(CAN_name, "CAN"))
		%assign CANNum = ""
    %else
		%assign CANNum = IDNUM("%<CAN_name>")[1]
    %endif

    %if EXISTS(::VarDef_%<CAN_name>) && (::VarDef_%<CAN_name> == TLC_TRUE)
        %assign ::VarDef_%<CAN_name>    = TLC_FALSE		
        %openfile CAN_Buf
            /* %<CAN_name> handler */
            extern CAN_HandleTypeDef hcan%<CANNum>;
        %closefile CAN_Buf
        %<LibSetSourceFileSection(modelH_CAN,"Defines",CAN_Buf)>
	%endif		

	%if (ISEQUAL(CAN_It,"on"))
	%%INTERRUPT MODE
     %if EXISTS(::DataReady_%<CAN_name>) && (::DataReady_%<CAN_name> == TLC_TRUE)
		%assign ::DataReady_%<CAN_name>  = TLC_FALSE		
        %openfile CAN_Buf
		/* %<CAN_name> Data Ready flag for read data interrupt mode*/	
		uint8_t	G_%<CAN_name>_DataReady = 0;
        %closefile CAN_Buf
        %<LibSetSourceFileSection(modelC_CAN,"Defines",CAN_Buf)>
        %openfile CAN_Buf
		/* %<CAN_name> Data Ready flag for read data interrupt mode*/	
		extern uint8_t	G_%<CAN_name>_DataReady;
        %closefile CAN_Buf
        %<LibSetSourceFileSection(modelH_CAN,"Defines",CAN_Buf)>				
	 %endif 
	%else
	%%POOLING MODE
     %if EXISTS(::RxMessage_%<CAN_name>) && (::RxMessage_%<CAN_name> == TLC_TRUE)
		%assign ::RxMessage_%<CAN_name>  = TLC_FALSE		
        %openfile CAN_Buf
		/* %<CAN_name> Receive Message definition*/	
		CanRxMsgTypeDef	RxMessage_%<CAN_name>;
        %closefile CAN_Buf
        %<LibSetSourceFileSection(modelC_CAN,"Defines",CAN_Buf)>
        %openfile CAN_Buf
		/* %<CAN_name> Receive Message*/	
		extern CanRxMsgTypeDef	RxMessage_%<CAN_name>;
        %closefile CAN_Buf
        %<LibSetSourceFileSection(modelH_CAN,"Defines",CAN_Buf)>				
	 %endif 
	%endif
	
    %endfunction
%else
%% ERROR CAN INIT MUST BE CALLED ONCE ONLY 
   %trace ERROR CAN INIT MUST BE CALLED ONCE ONLY 
%endif 

%% Function: Outputs ==========================================
%% Abstract:
%% CAN_Receive input value depending on pin config
%%
   %function Outputs(block, system) Output
	/* %<Type> Block: %<Name> */  
        %%model_CAN.h and model_CAN.c files
        %assign SrcBaseName = LibGetMdlSrcBaseName()
        %assign SrcBaseName_CAN = "%<SrcBaseName>_CAN"
        %assign modelH_CAN      = LibCreateSourceFile("Header", "Simulink", SrcBaseName_CAN)
        %assign modelC_CAN      = LibCreateSourceFile("Source", "Simulink", SrcBaseName_CAN)


        %assign CAN_name =  SFcnParamSettings.CAN_name
        %assign CAN_Fifo =  SFcnParamSettings.CAN_Fifo
        %assign CAN_It =  SFcnParamSettings.CAN_It
        %assign CAN_Rcv_TimeOut =  SFcnParamSettings.CAN_Rcv_TimeOut
        %assign CAN_Mode =  SFcnParamSettings.CAN_Mode		
        %assign nbCAN =  SFcnParamSettings.nbCAN

		%if (ISEQUAL(CAN_name, "CAN"))
			%assign CANNum = ""
		%else
			%assign CANNum = IDNUM("%<CAN_name>")[1]
		%endif
		
		
	%if (ISEQUAL(CAN_It,"off"))
	  %%POOLING MODE
		%assign stand_ext = LibBlockOutputSignal(0, "", "", 0) 		
		%assign ideBit = LibBlockOutputSignal(1, "", "", 0) 		
		%assign dataRequest = LibBlockOutputSignal(2, "", "", 0) 		
		%assign nbData = LibBlockOutputSignal(3, "", "", 0) 		
		%assign data = LibBlockOutputSignal(4, "", "", 0) 		
		/* Receive data */		
		if(HAL_CAN_Receive(&hcan%<CANNum>, %<CAN_Fifo>, %<CAN_Rcv_TimeOut>) == HAL_OK){
			/* Get received frame information */
			%<stand_ext> =(uint8_t)hcan%<CANNum>.pRxMsg->IDE;
			%<dataRequest> =(uint8_t)hcan%<CANNum>.pRxMsg->RTR;
			%<nbData> =(uint16_t)hcan%<CANNum>.pRxMsg->DLC;
			//RP MODIF %<data> =(uint8_t)hcan%<CANNum>.pRxMsg->Data;
			strncpy((char*)&%<data>,(char const*)hcan%<CANNum>.pRxMsg->Data,(uint32_t)hcan%<CANNum>.pRxMsg->DLC);
			
			if(hcan%<CANNum>.pRxMsg->IDE == CAN_ID_STD){
				%<ideBit> =(uint32_t)hcan%<CANNum>.pRxMsg->StdId;
			} else {
				%<ideBit> =(uint32_t)hcan%<CANNum>.pRxMsg->ExtId;
			}
		} 
	%else		
	  %%INTERRUPT MODE
	    /* Reset Interrupt data received flag */
		G_%<CAN_name>_DataReady = 0;
		/* Ask for data */
		HAL_CAN_Receive_IT(&hcan%<CANNum>, %<CAN_Fifo>);
	%endif	
   %endfunction

%% [EOF] CAN_Reset.tlc






