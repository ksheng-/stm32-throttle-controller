%% $RCSfile: SPI.tlc,v $
%% $Revision: 1.0 $
%% $Date: 2012/01/26 $
%%
%% Abstract: SPI
%%    STM32Fxxx SPI for the transmision of all the data 
%%
%% Copyright 1990-2009 The MathWorks, Inc.

%assign CodeFormat = "Embedded-C"
%implements SPI  "C"

%if !EXISTS(::InsertIncludesToSPI)
    %assign ::InsertIncludesToSPI  = TLC_TRUE
%endif 
%if !EXISTS(::InsertIncludesFromSPI)
    %assign ::InsertIncludesFromSPI  = TLC_TRUE
%endif 

%if !EXISTS(::CreateSPI)
    %assign ::CreateSPI  = TLC_TRUE
%endif

%if !EXISTS(::Create_R_CallBack_FCN)
    %assign ::Create_R_CallBack_FCN  = TLC_TRUE
%endif

%if !EXISTS(::Create_R_Transmission_FCN)
    %assign ::Create_R_Transmission_FCN  = TLC_TRUE
%endif

%if !EXISTS(::Create_R_Transmission_reception_FCN)
    %assign ::Create_R_Transmission_reception_FCN  = TLC_TRUE
%endif

%if !EXISTS(::Create_R_ERROR_FCN)
    %assign ::Create_R_ERROR_FCN  = TLC_TRUE
%endif

%if !EXISTS(::InsertRxSPI)
    %assign ::InsertRxSPI  = TLC_TRUE
%endif

%if !EXISTS(::InsertTxSPI)
    %assign ::InsertTxSPI  = TLC_TRUE
%endif

%if !EXISTS(::InsertTxSPI_Fonction)
    %assign ::InsertTxSPI_Fonction  = TLC_TRUE
%endif

%if !EXISTS(::InsertRxSPI_Fonction)
    %assign ::InsertRxSPI_Fonction  = TLC_TRUE
%endif

%if !EXISTS(::InsertRxSPI_buffer)
    %assign ::InsertRxSPI_buffer  = TLC_TRUE
%endif

%if !EXISTS(::InsertTxSPI_buffer)
    %assign ::InsertTxSPI_buffer  = TLC_TRUE
%endif

%assign Handler =  SFcnParamSettings.Handler
%if !EXISTS(::Create_%<Handler>)
    %assign ::Create_%<Handler>  = TLC_TRUE
%endif


%assign ::CreateSPI  = TLC_TRUE
%trace CreateSPI  %<CreateSPI>


%% *************************************************************************************
%% ******************      Fonction : Start        *************************************
%% ************************************************************************************* 

%function Start(block,system) Output  
%% fait dans la fonction MX_SPI_Init
    %assign SPIx =  SFcnParamSettings.SPIx
    %assign Type_SPI =  SFcnParamSettings.Type_SPI
    %if(ISEQUAL(Type_SPI, "Receive_Only"))
        %% Initialization is done once only per SPI
        %if !EXISTS(::%<SPIx>_RX_START)
            %assign ::%<SPIx>_RX_START  = TLC_TRUE
            %openfile SPI_Buf
                /* %<SPIx> initialization for receive*/
                %<SPIx>_Rx_Initialization();
            %closefile SPI_Buf
            %<LibMdlStartCustomCode(SPI_Buf,"execution")>
            
        %endif
    %endif
    %if(ISEQUAL(Type_SPI, "Transmit_Only"))
        %% Initialization is done once only per SPI
        %if !EXISTS(::%<SPIx>_TX_START)
            %assign ::%<SPIx>_TX_START  = TLC_TRUE
            %openfile SPI_Buf
            /* %<SPIx> initialization for send*/
            %<SPIx>_Tx_Initialization();
            %closefile SPI_Buf
            %<LibMdlStartCustomCode(SPI_Buf,"execution")>
        %endif
    %endif
    %if(ISEQUAL(Type_SPI, "Full_Duplex")||ISEQUAL(Type_SPI, "Half_Duplex"))
        %% Initialization is done once only per SPI
        %if !EXISTS(::%<SPIx>_TX_RX_START)
            %assign ::%<SPIx>_TX_RX_START  = TLC_TRUE
            %openfile SPI_Buf
                /* %<SPIx> initialization for receive and transmit*/
                %<SPIx>_Tx_Rx_Initialization();
            %closefile SPI_Buf
            %<LibMdlStartCustomCode(SPI_Buf,"execution")>
            
        %endif
    %endif
    
%endfunction	



%% *************************************************************************************
%% ******************      Fonction : BlockInstanceSetup       *************************
%% ************************************************************************************* 

%if EXISTS(CreateSPI) && (CreateSPI == TLC_TRUE)
    %% fonction faite une seul fois
    %function BlockInstanceSetup(block, system) void
        %%model.c and model.h files
        %%création des fichiers .c et .h pour le général
        %assign SrcBaseName = LibGetMdlSrcBaseName()
        %assign modelH      = LibCreateSourceFile("Header", "Simulink", SrcBaseName)
        %assign modelC      = LibCreateSourceFile("Source", "Simulink", SrcBaseName)
        %%model_SPI.h and model_SPI.c files
        %%création des fichiers .c et .h pour le SPI
        %assign SrcBaseName_SPI = "%<SrcBaseName>_SPI"
        %assign modelH_SPI      = LibCreateSourceFile("Header", "Simulink", SrcBaseName_SPI)
        %assign modelC_SPI      = LibCreateSourceFile("Source", "Simulink", SrcBaseName_SPI)



        
        %if EXISTS(::InsertIncludesToSPI) && (::InsertIncludesToSPI == TLC_TRUE)
            %assign ::InsertIncludesToSPI    = TLC_FALSE		
            %openfile SPI_Buf
				#include "%<SrcBaseName>.h"
				#include "%<SrcBaseName_SPI>.h"
            %closefile SPI_Buf
            %%on dit dans quel fichier on veut mettre la donnée
            %<LibSetSourceFileSection(modelC_SPI,"Includes",SPI_Buf)>
        %endif
%%AND Include model_SPI.h to model.c
        %if EXISTS(::InsertIncludesFromSPI) && (::InsertIncludesFromSPI == TLC_TRUE)
            %assign ::InsertIncludesFromSPI    = TLC_FALSE		
            %openfile SPI_Buf
				#include "%<SrcBaseName_SPI>.h"
            %closefile SPI_Buf
            %<LibSetSourceFileSection(modelH,"Includes",SPI_Buf)>
            
			%openfile SPI_Buf
				//RP MODIF #include "%<SrcBaseName>_STM32.h"
				#include "STM32_Config.h"
            %closefile SPI_Buf
            %<LibSetSourceFileSection(modelH_SPI,"Includes",SPI_Buf)>						
        %endif

        %%recuperation des donées transmises par SPI.c
		%assign SPIx =  SFcnParamSettings.SPIx
        %assign Device_Mode =  SFcnParamSettings.Device_Mode
        %assign Type_SPI =  SFcnParamSettings.Type_SPI
		%assign SPI_Mode = SFcnParamSettings.SPI_Mode
        %assign Handler =  SFcnParamSettings.Handler	
        %assign Buffer_Size_Rcv = SFcnParamSettings.Buffer_Size_Rcv
        %assign Buffer_Size_Send = SFcnParamSettings.Buffer_Size_Send	
        %assign NbSPI = SFcnParamSettings.NbSPI
		%assign Timeout = SFcnParamSettings.TimeoutValue
        %assign NSS = SFcnParamSettings.NSS
		%assign Error = SFcnParamSettings.Error
		%assign CallBack = SFcnParamSettings.CallBack
		%assign Transmission = SFcnParamSettings.Transmission
		%assign block_name =  block.Identifier	
       %% %assign IRQ_TX = SFcnParamSettings.IRQ_TX
		
		%assign SPINum = IDNUM("%<SPIx>")[1]
        %assign SPINombre=IDNUM("%<NbSPI>")[1]
        %assign Buffer_Send=IDNUM("%<Buffer_Size_Send>")[1]
        %assign Buffer_Rcv=IDNUM("%<Buffer_Size_Rcv>")[1]	
  
    

		
	%% *************************************************************************************
	%% **********************INITIALISATION DES MODULES SPI*********************************

	
	
	%% *********************FIN INITIALISATION DES MODULES SPI******************************
	%% *************************************************************************************
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
        
       %% *************************************************************************************
        %% variable for transmission
        %% *************************************************************************************
        %if(ISEQUAL(Type_SPI, "Full_Duplex")||ISEQUAL(Type_SPI, "Half_Duplex"))
             %if EXISTS(::InsertTxSPI) && (::InsertTxSPI == TLC_TRUE)
                %assign ::InsertTxSPI    = TLC_FALSE		
                %openfile SPI_Buf
                    /** 
                    * @brief SPI Tx and RX State structures definition  
                    */ 
                    typedef enum
                    {
                    SPI_TX_RX_ON             = 0x00,    /*!< Tx_Rx SPI communication start   */
                    SPI_TX_RX_OK             = 0x01,    /*!< Tx_Rx SPI communication terminated. Data available */
                    SPI_TX_RX_OFF            = 0x02     /*!< Tx_Rx SPI communication stop */      
                    }SPI_TxRxStatusTypeDef;
                    /** 
                    * @brief  SPI data information
                    */ 
                    typedef struct SPI_TxRxDataLinkTypeDef	{
                             uint16_t                nb2Send;       /*!< Nb of char to send*/
                             uint16_t                nb2Rcv;       /*!< Nb of char to send*/    
                             uint16_t                nbSent;        /*!< Nb sent char*/
                             uint16_t                nbRcv;        /*!< Nb sent char*/
                             uint16_t                nbMsgLost;     /*!< Nb lost msg (not enought space in ring buffer)*/
                             uint16_t                bufferSizeSend;      /*!< Size of send ring buffer*/
                             uint16_t                bufferSizeRcv;      /*!< Size of receive buffer*/
                             uint8_t*                pt_StartTx_Buff; /*!< point to ring buffer*/
                             uint8_t*                pt_EndTx_Buff; /*!< point to end ring buffer*/
                             uint8_t*                pt_Tx_W;       /*!< point to free space*/
                             uint8_t*                pt_Tx_R;       /*!< point to char to send*/
                             uint8_t*                ptRcv;         /*!< Point to receive data value buffer*/
                             void     (* CopyDataFcnSendRcv)(uint8_t* ptSrc, uint16_t DataLength, struct SPI_TxRxDataLinkTypeDef* ptInfo);  
                             void     (* SendReceiveDataFcn)(struct SPI_TxRxDataLinkTypeDef* ptInfo);  
                             __IO SPI_TxRxStatusTypeDef   txrxStatus;	    /*!< SPI send communication status.*/
                             uint8_t                 txrxLock;        /*!< lock data access */
                    }SPI_TxRxDataLinkTypeDef;
                    
                    /*void     %<SPIx>_CopyDataFcnSendRcv (uint8_t*, uint16_t, struct SPI_TxDataLinkTypeDef* ); 
                    void     %<SPIx>_SendReceiveDataFcn (struct SPI_TxDataLinkTypeDef* );  
                    uint32_t getBuffPtr_SPI(uint8_t*);*/ /* Function prototype used from MATLAB script */ 
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>
             %endif
        %endif
        
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
        %% *************************************************************************************
        %% variable for transmission
        %% *************************************************************************************
        %if(ISEQUAL(Type_SPI, "Transmit_Only"))
             %if EXISTS(::InsertTxSPI) && (::InsertTxSPI == TLC_TRUE)
                %assign ::InsertTxSPI    = TLC_FALSE		
                %openfile SPI_Buf
                    /** 
                    * @brief SPI Tx State structures definition  
                    */ 
                    typedef enum
                    {
                    SPI_TX_ON             = 0x00,    /*!< Tx SPI communication start   */
                    SPI_TX_OK             = 0x01,    /*!< Tx SPI communication terminated. Data available */
                    SPI_TX_OFF            = 0x02     /*!< Tx SPI communication stop */      
                    }SPI_TxStatusTypeDef;
                    /** 
                    * @brief  SPI data information
                    */ 
                    typedef struct SPI_TxDataLinkTypeDef	{
                             uint16_t                nb2Send;       /*!< Nb of char to send*/
                             uint16_t                nbSent;        /*!< Nb sent char*/
                             uint16_t                nbMsgLost;     /*!< Nb lost msg (not enought space in ring buffer)*/
                             uint16_t                bufferSize;      /*!< Size of send ring buffer*/
                             uint8_t*                pt_StartTx_Buff; /*!< point to ring buffer*/
                             uint8_t*                pt_EndTx_Buff; /*!< point to end ring buffer*/
                             uint8_t*                pt_Tx_W;       /*!< point to free space*/
                             uint8_t*                pt_Tx_R;       /*!< point to char to send*/
                             void     (* CopyDataFcn)(uint8_t* ptSrc, uint16_t DataLength, struct SPI_TxDataLinkTypeDef* ptInfo);  
                             void     (* SendDataFcn)(struct SPI_TxDataLinkTypeDef* ptInfo);  
                             __IO SPI_TxStatusTypeDef   txStatus;	    /*!< SPI send communication status.*/
                             uint8_t                 txLock;        /*!< lock data access */
                    }SPI_TxDataLinkTypeDef;
                    
                    void     %<SPIx>_CopyDataFcn (uint8_t*, uint16_t , struct SPI_TxDataLinkTypeDef* ); 
                    void     %<SPIx>_SendDataFcn (struct SPI_TxDataLinkTypeDef* );  
                    uint32_t getBuffPtr_SPI(uint8_t*); /* Function prototype used from MATLAB script */ 
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>
             %endif
        %endif
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
     %% *************************************************************************************
        %% variable for receipt
        %% *************************************************************************************
        %if(ISEQUAL(Type_SPI, "Receive_Only"))
            %if EXISTS(::InsertRxSPI) && (::InsertRxSPI == TLC_TRUE)
                %assign ::InsertRxSPI    = TLC_FALSE		
                %openfile SPI_Buf
                    /** 
                    * @brief SPI Rx State structures definition  
                    */ 
                    typedef enum
                    {
                    SPI_RX_ON             = 0x00,    /*!< Rx SPI communication start   */
                    SPI_RX_OK             = 0x01,    /*!< Rx SPI communication terminated. Data available */
                    SPI_RX_OFF            = 0x02     /*!< Rx SPI communication stop */      
                    }SPI_RxStatusTypeDef;
                    /** 
                    * @brief  SPI data information
                    */ 
                    typedef struct SPI_RxDataLinkTypeDef 	{
                     uint8_t*                ptRcv;         /*!< Point to receive data value buffer*/
                     __IO SPI_RxStatusTypeDef   rxStatus;	    /*!< SPI receive communication status.*/
                    }SPI_RxDataLinkTypeDef ;

                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>
             %endif
        %endif

     %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
    %% *************************************************************************************
    %% definition of pointer for the transmission
    %% *************************************************************************************
        %if(ISEQUAL(Type_SPI, "Full_Duplex")||ISEQUAL(Type_SPI, "Half_Duplex")||ISEQUAL(Type_SPI, "Transmit_Only"))
            %if EXISTS(::InsertTxSPI_Fonction) && (::InsertTxSPI_Fonction == TLC_TRUE)
                %assign ::InsertTxSPI_Fonction = TLC_FALSE
                 %if(ISEQUAL(Type_SPI, "Transmit_Only"))
                    %openfile SPI_Buf
                        %if (SPINombre >1)
                            uint16_t               G_NbSPITxConf = 0; /* Number of SPI configured for transmit*/
                            /* Array of SPI transmit data information */
                            struct SPI_TxDataLinkTypeDef*   G_SPI_TxData[%<NbSPI>];
                            void*     G_SPI_TxHandler[%<NbSPI>];
                        %else
                            struct SPI_TxDataLinkTypeDef*   G_SPI_TxData;      /* Pointer to SPI transmit data information*/
                            void*     G_SPI_TxHandler;   /* Pointer to SPI handler configured for trnasmit*/
                        %endif
                    %closefile SPI_Buf
                    %<LibSetSourceFileSection(modelC_SPI,"Defines",SPI_Buf)>
                %else
                	%% *************************************************************************************
                    %% definition of pointer for the receipt and transmit (full and half duplex)
                    %% *************************************************************************************
                    %openfile SPI_Buf
                        %if (SPINombre >1)
                            uint16_t               G_NbSPITxConf = 0; /* Number of SPI configured for transmit*/
                            /* Array of SPI transmit data information */
                            struct SPI_TxRxDataLinkTypeDef*   G_SPI_TxData[%<NbSPI>];
                            void*     G_SPI_TxHandler[%<NbSPI>];
                        %else
                            struct SPI_TxRxDataLinkTypeDef*   G_SPI_TxData;      /* Pointer to SPI transmit data information*/
                            void*     G_SPI_TxHandler;   /* Pointer to SPI handler configured for trnasmit*/
                        %endif
                    %closefile SPI_Buf
                    %<LibSetSourceFileSection(modelC_SPI,"Defines",SPI_Buf)>
                    %openfile SPI_Buf
                        %if (SPINombre >1)
                            uint16_t               G_NbSPIRxConf = 0; /* Number of SPI configured for receive*/
                            /* Array of SPI receive data information */
                            SPI_TxRxDataLinkTypeDef*   G_SPI_RxData[%<NbSPI>];
                            void*     G_SPI_RxHandler[%<NbSPI>];
                        %else
                            SPI_TxRxDataLinkTypeDef*   G_SPI_RxData;      /* Pointer to SPI receive data information*/
                            void*     G_SPI_RxHandler;   /* Pointer to SPI handler configured for receive*/
                        %endif
                    %closefile SPI_Buf
                    %<LibSetSourceFileSection(modelC_SPI,"Defines",SPI_Buf)>
                %endif

                %openfile SPI_Buf
                /* Declaration  of getBuffPtr_SPI*/
                uint32_t getBuffPtr_SPI(uint8_t*);
                
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Functions",SPI_Buf)>	




                %openfile SPI_Buf
                    /*******************************************************************************
                    * Function Name  : getBuffPtr_SPI
                    * Description    : Return buffer address. This function is called from MATLAB script
                    *                  using coder.ceval('getBuffPtr',coder.rref(buffer))
                    *                  to get buffer address to send
                    * Input          : buffPtr
                    *******************************************************************************/
                    uint32_t getBuffPtr_SPI(uint8_t* buffPtr)
                    {
                        return((uint32_t)buffPtr);
                    }	
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)>	
            %endif
        %endif
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
	%% *************************************************************************************
    %% definition of pointer for the receipt
    %% *************************************************************************************
        %if(ISEQUAL(Type_SPI, "Receive_Only"))
            %if EXISTS(::InsertRxSPI_Fonction) && (::InsertRxSPI_Fonction == TLC_TRUE)
                %assign ::InsertRxSPI_Fonction = TLC_FALSE
                %openfile SPI_Buf
                    %if (SPINombre >1)
                        uint16_t               G_NbSPIRxConf = 0; /* Number of SPI configured for receive*/
                        /* Array of SPI receive data information */
                        SPI_RxDataLinkTypeDef*   G_SPI_RxData[%<NbSPI>];
                        void*     G_SPI_RxHandler[%<NbSPI>];
                    %else
                        SPI_RxDataLinkTypeDef*   G_SPI_RxData;      /* Pointer to SPI receive data information*/
                        void*     G_SPI_RxHandler;   /* Pointer to SPI handler configured for receive*/
                    %endif
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Defines",SPI_Buf)>
            %endif
        %endif
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************

     
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
    %% *************************************************************************************
    %% call of the callback for finish the receipt
    %% *************************************************************************************  		   
         %if(ISEQUAL(CallBack, "on"))
            %if EXISTS(::Create_R_CallBack_FCN) && (::Create_R_CallBack_FCN == TLC_TRUE)
                %assign ::Create_R_CallBack_FCN   = TLC_FALSE		
                %openfile SPI_Buf	
                   
                    /* Blockset SPI Rx CallBack function prototype */
                    extern void (* ItCallBackRxFcn)(void);  
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>
                %openfile SPI_Buf	
                    /* Blockset SPI Rx CallBack function to run */
                    void (* ItCallBackRxFcn)(void);  
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Defines",SPI_Buf)>
            %endif
          


            %openfile SPI_Buf
                /*******************************************************************************
                * Function Name  : HAL_SPI_RxCpltCallback
                * Description    : Rx Transfer completed callbacks. 
                * Input          : SPI handler
                *******************************************************************************/
                void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
                {
                   %if(ISEQUAL(NSS, "on"))
                        __HAL_SPI_DISABLE(hspi);
                    %endif
                    if(ItCallBackRxFcn != NULL)
                    {
                        /* Call Blockset CallBack function */
                        ItCallBackRxFcn();
                        %if(ISEQUAL(Type_SPI, "Receive_Only"))
                            %<SPIx>_RxDataLink.rxStatus = SPI_RX_OK;
                        %endif
                        %if(ISEQUAL(Type_SPI, "Full_Duplex")||ISEQUAL(Type_SPI, "Half_Duplex"))
                            %<SPIx>_TxRxDataLink.txrxStatus = SPI_TX_RX_OK;
                        %endif
                     }
                }   

            %closefile SPI_Buf
            %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)> 
        %endif
        
    %% *************************************************************************************
    %% call of the callback for finish the transmission
    %% *************************************************************************************  		   
     	%if(ISEQUAL(Transmission, "on"))
            %if EXISTS(::Create_R_Transmission_FCN) && (::Create_R_Transmission_FCN == TLC_TRUE)
                %assign ::Create_R_Transmission_FCN   = TLC_FALSE		
                %openfile SPI_Buf	
                    /* Blockset SPI Tx Transmission function prototype */
                    extern void (* ItTransmissionTxFcn)(void);  
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>
                %openfile SPI_Buf	
                    /* Blockset SPI Tx CallBack function to run */
                    void (* ItTransmissionTxFcn)(void);  
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Defines",SPI_Buf)>
            %endif

            %openfile SPI_Buf

               /*******************************************************************************
                * Function Name  : HAL_SPI_TxCpltCallback
                * Description    : Rx Transfer completed callbacks. 
                * Input          : SPI handler
                *******************************************************************************/
                void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
                {
                    %if(ISEQUAL(NSS, "on"))
                        __HAL_SPI_DISABLE(hspi);
                    %endif
                    if(ItTransmissionTxFcn != NULL)
                    {
                        /* Call Blockset CallBack function */
                        ItTransmissionTxFcn();
                     }
                }   

            %closefile SPI_Buf
            %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)> 
        %endif


    %% *************************************************************************************
    %% call of the callback for finish the transmission and reception in full or half duplex
    %% *************************************************************************************  		   
     	%if(ISEQUAL(Transmission, "on") || ISEQUAL(CallBack, "on")&&(ISEQUAL(Type_SPI, "Full_Duplex")||ISEQUAL(Type_SPI, "Half_Duplex")))
            %if EXISTS(::Create_R_Transmission_reception_FCN) && (::Create_R_Transmission_reception_FCN == TLC_TRUE)
                %assign ::Create_R_Transmission_reception_FCN   = TLC_FALSE		
                %openfile SPI_Buf	
                    /* Blockset SPI Tx Rx function prototype */
                    extern void (* ItTxRxFcn)(void);  
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>
                %openfile SPI_Buf	
                    /* Blockset SPI Tx Rx CallBack function to run */
                    void (* ItTxRxFcn)(void);  
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Defines",SPI_Buf)>
            %endif

            %openfile SPI_Buf

               /*******************************************************************************
                * Function Name  : HAL_SPI_TxRxCpltCallback
                * Description    : Rx Transfer completed callbacks. 
                * Input          : SPI handler
                *******************************************************************************/
                void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
                {
                    %if(ISEQUAL(NSS, "on"))
                        __HAL_SPI_DISABLE(hspi);
                    %endif
                    %if(ISEQUAL(Transmission, "on"))
                            if(ItTransmissionTxFcn != NULL)
                            {
                                /* Call Blockset CallBack function */
                                ItTransmissionTxFcn();
                             }
                    %endif
                    %if(ISEQUAL(CallBack, "on"))
                        if(ItCallBackRxFcn != NULL)
                        {
                            /* Call Blockset CallBack function */
                            ItCallBackRxFcn();
                         }
                    %endif
                }   

            %closefile SPI_Buf
            %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)> 
        %endif
    %% *************************************************************************************
    %% call of the callback for finish the Error
    %% *************************************************************************************  		   
        %if(ISEQUAL(Error, "on"))
            %if EXISTS(::Create_R_ERROR_FCN) && (::Create_R_ERROR_FCN == TLC_TRUE)
                %assign ::Create_R_ERROR_FCN   = TLC_FALSE		
                %openfile SPI_Buf	
                    /* Blockset SPI Rx CallBack function prototype */
                    extern void (* ItErrorFcn)(void);  
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>
                %openfile SPI_Buf	
                    /* Blockset SPI Rx CallBack function to run */
                    void (* ItErrorFcn)(void);  
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Defines",SPI_Buf)>
            %endif


            %openfile SPI_Buf

               /*******************************************************************************
                * Function Name  : HAL_SPI_ErrorCallback
                * Description    : Transfer Error in the transmission. 
                * Input          : SPI handler
                *******************************************************************************/
                void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
                {
                        __HAL_SPI_DISABLE(hspi);
                    if(ItErrorFcn != NULL)
                    {
                        /* Call Blockset CallBack function */
                        ItErrorFcn();
                     }
                }   

            %closefile SPI_Buf
            %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)>
        %endif

 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************     

    %% *************************************************************************************
    %% definition of the transmission size buffer for TX 
    %% *************************************************************************************
        %if(ISEQUAL(Type_SPI, "Transmit_Only"))
            %%if EXISTS(::InsertTxSPI_buffer) && (::InsertTxSPI_buffer == TLC_TRUE)
                %%assign ::InsertTxSPI_buffer    = TLC_FALSE
            %if !EXISTS(::%<SPIx>_TX_buffer)
                %assign ::%<SPIx>_TX_buffer  = TLC_TRUE
                %openfile SPI_Buf
                    /* %<SPIx> transmit data buffer*/
                    uint8_t G_%<SPIx>_TxDataBuffer[%<Buffer_Send>];	
                    /* %<SPIx> transmit data structure information*/
                    struct SPI_TxDataLinkTypeDef   %<SPIx>_TxDataLink;		
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Defines",SPI_Buf)>



    %%*************************************************************************
    %% Code for required SPI external definition: in model_SPI.c file
    %%*************************************************************************    
                %openfile SPI_Buf
                    /* %<SPIx> handler */
                    extern SPI_HandleTypeDef hspi%<SPINum>;
                    %%test for DMA handler

                    %if (ISEQUAL(SPI_Mode, "IT_DMA_TX")||ISEQUAL(SPI_Mode, "DMA_TX")||ISEQUAL(SPI_Mode, "IT_DMA_RX_TX")||ISEQUAL(SPI_Mode, "DMA_RX_TX"))
                        extern DMA_HandleTypeDef hdma_SPI%<SPINum>_tx;
                    %endif

                    /* %<SPIx> Transmit data buffer*/
                    extern uint8_t G_%<SPIx>_TxDataBuffer[];	
                    /* %<SPIx> Transmit data structure information*/
                    extern struct SPI_TxDataLinkTypeDef   %<SPIx>_TxDataLink;								
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>
            %endif
        %endif   	
%%*******************************************************************************************************************************************************
%%*******************************************************************************************************************************************************
%%*******************************************************************************************************************************************************
   
    %% *************************************************************************************
    %% definition of the transmission size buffer for TX and RX
    %% *************************************************************************************
        %if(ISEQUAL(Type_SPI, "Full_Duplex")||ISEQUAL(Type_SPI, "Half_Duplex"))
            %%if EXISTS(::InsertTxSPI_buffer) && (::InsertTxSPI_buffer == TLC_TRUE)
                %%assign ::InsertTxSPI_buffer    = TLC_FALSE
            %if !EXISTS(::%<SPIx>_TX_Rx_buffer)
                %assign ::%<SPIx>_TX_Rx_buffer  = TLC_TRUE
                %openfile SPI_Buf
                    /* %<SPIx> transmit data buffer*/
                    uint8_t G_%<SPIx>_TxRxDataSendBuffer[%<Buffer_Send>];	
                    /* %<SPIx> transmit data structure information*/
                    struct SPI_TxRxDataLinkTypeDef   %<SPIx>_TxRxDataLink;		
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Defines",SPI_Buf)>



    %%*************************************************************************
    %% Code for required SPI external definition: in model_SPI.c file
    %%*************************************************************************    
                %openfile SPI_Buf
                    /* %<SPIx> handler */
                    extern SPI_HandleTypeDef hspi%<SPINum>;
                    %%test for DMA handler

                    %if (ISEQUAL(SPI_Mode, "IT_DMA_TX")||ISEQUAL(SPI_Mode, "DMA_TX")||ISEQUAL(SPI_Mode, "IT_DMA_RX_TX")||ISEQUAL(SPI_Mode, "DMA_RX_TX"))
                        extern DMA_HandleTypeDef hdma_SPI%<SPINum>_tx;
                    %endif

                    /* %<SPIx> Transmit data buffer*/
                    extern uint8_t G_%<SPIx>_TxRxDataSendBuffer[];	
                    /* %<SPIx> Transmit data structure information*/
                    extern struct SPI_TxRxDataLinkTypeDef   %<SPIx>_TxRxDataLink;								
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>
            %endif
            %if !EXISTS(::%<SPIx>_Rcv_buffer)
                %assign ::%<SPIx>_Rcv_buffer  = TLC_TRUE
                %openfile SPI_Buf
                    /* %<SPIx> Receive data buffer  %<Type_SPI>*/
                    uint8_t G_%<SPIx>_TxRxDataRcvBuffer[%<Buffer_Rcv>];	
                    /* %<SPIx> receive data structure information*/
                    struct SPI_TxRxDataLinkTypeDef   %<SPIx>_TxRxDataLink;		
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Defines",SPI_Buf)>

                 %openfile SPI_Buf
                    /* %<SPIx> handler */
                    extern SPI_HandleTypeDef hspi%<SPINum>;
                    %%test for DMA handler
                    %if (ISEQUAL(SPI_Mode, "IT_DMA_RX")||ISEQUAL(SPI_Mode, "DMA_RX")||ISEQUAL(SPI_Mode, "IT_DMA_RX_TX")||ISEQUAL(SPI_Mode, "DMA_RX_TX"))
                        extern DMA_HandleTypeDef hdma_SPI%<SPINum>_rx;
                    %endif

                    /* %<SPIx> Receive data buffer*/
                    extern uint8_t G_%<SPIx>_TxRxDataRcvBuffer[%<Buffer_Rcv>];	
                    /* %<SPIx> Receive data structure information*/
                    extern struct SPI_TxRxDataLinkTypeDef   %<SPIx>_TxRxDataLink;								
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>
            %endif
            %if !EXISTS(::%<SPIx>_TX_poll)
                %assign ::%<SPIx>_TX_poll  = TLC_TRUE
                %openfile SPI_Buf
                    %if (ISEQUAL(SPI_Mode, "POLLING")||ISEQUAL(SPI_Mode, "DMA_RX")|| ISEQUAL(SPI_Mode, "IT_DMA_RX"))
                        /* %<SPIx> Tx_Rx polling timeout value. Number of Solver loop. (can be changed)*/
                        uint32_t G_%<SPIx>_TxRxPollTimeOut = 10;
                    %endif				
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Definitions",SPI_Buf)>
            

                %openfile SPI_Buf
                    %if (ISEQUAL(SPI_Mode, "POLLING")||ISEQUAL(SPI_Mode, "DMA_RX")|| ISEQUAL(SPI_Mode, "IT_DMA_RX"))
                        /* %<SPIx> Tx_Rx polling timeout value. Number of Solver loop. (can be changed)*/
                        extern uint32_t G_%<SPIx>_TxRxPollTimeOut;
                    %endif				
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>
            %endif
        %endif
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
        %if(ISEQUAL(Type_SPI, "Full_Duplex")||ISEQUAL(Type_SPI, "Half_Duplex"))
            %if !EXISTS(::%<SPIx>_TX_INIT)
                %assign ::%<SPIx>_TX_INIT  = TLC_TRUE
                %openfile SPI_Buf
                /* %<SPIx>_Tx_Rx_Initialization prototyping */
                void %<SPIx>_Tx_Rx_Initialization(void);
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>
                
                 %openfile SPI_Buf
                /*******************************************************************************
                * Function Name  : %<SPIx>_Tx_Rx_Initialization
                * Description    : Send and Receive Initialization of %<SPIx>
                * Input          : -
                *******************************************************************************/
                void %<SPIx>_Tx_Rx_Initialization(void)
                {
                %if(%<SPINombre> > 1)						
                    /*Store %<SPIx> send data information and its handler */ 
                    G_SPI_TxData[G_NbSPITxConf] = &%<SPIx>_TxRxDataLink;
                    G_SPI_TxHandler[G_NbSPITxConf] = (void*)&hspi%<SPINum>;
                    G_NbSPITxConf++; /*Inc number of configured SPI for send*/
                    /*Store %<SPIx> receive data information and its handler */ 
                    G_SPI_RxData[G_NbSPIRxConf] = &%<SPIx>_TxRxDataLink;
                    G_SPI_RxHandler[G_NbSPIRxConf] = (void*)&hspi%<SPINum>;
                    G_NbSPIRxConf++; /*Inc number of configured USART for receive*/
                %else
                    /*Store %<SPIx> send data information and its handler */ 
                    G_SPI_TxData = &%<SPIx>_TxRxDataLink;
                    G_SPI_TxHandler = (void*)&hspi%<SPINum>;
                    /*Store %<SPIx> receive data information and its handler */ 
                    G_SPI_RxData = &%<SPIx>_TxRxDataLink;
                    G_SPI_RxHandler = (void*)&hspi%<SPINum>;
                %endif
                    /* Initialize ring buffer information */
                    %<SPIx>_TxRxDataLink.nb2Send = 0;
                    %<SPIx>_TxRxDataLink.nb2Rcv = 0;
                    %<SPIx>_TxRxDataLink.nbSent = 0;
                    %<SPIx>_TxRxDataLink.nbRcv = 0;
                    %<SPIx>_TxRxDataLink.nbMsgLost = 0;   
                    %<SPIx>_TxRxDataLink.bufferSizeSend = %<Buffer_Send>;
                    %<SPIx>_TxRxDataLink.bufferSizeRcv = %<Buffer_Rcv>;
                    %<SPIx>_TxRxDataLink.pt_StartTx_Buff = G_%<SPIx>_TxRxDataSendBuffer;
                    %<SPIx>_TxRxDataLink.pt_EndTx_Buff = &G_%<SPIx>_TxRxDataSendBuffer[%<Buffer_Send>];
                    %<SPIx>_TxRxDataLink.pt_Tx_W = G_%<SPIx>_TxRxDataSendBuffer;
                    %<SPIx>_TxRxDataLink.pt_Tx_R = G_%<SPIx>_TxRxDataSendBuffer;
                    %<SPIx>_TxRxDataLink.ptRcv = G_%<SPIx>_TxRxDataRcvBuffer;
                    %<SPIx>_TxRxDataLink.CopyDataFcnSendRcv = %<SPIx>_CopyDataFcnSendRcv;  
                    %<SPIx>_TxRxDataLink.SendReceiveDataFcn = %<SPIx>_SendReceiveDataFcn;  
                    %<SPIx>_TxRxDataLink.txrxStatus =  SPI_TX_RX_OFF;
                    %<SPIx>_TxRxDataLink.txrxLock = 0;
                }  		
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)>
            %endif
             %if !EXISTS(::%<SPIx>_CopyDataFcn)
                %assign ::%<SPIx>_CopyDataFcn  = TLC_TRUE
                %openfile SPI_Buf
                /* %<SPIx>_CopyDataFcnSendRcv prototyping */
                void %<SPIx>_CopyDataFcnSendRcv(uint8_t*,uint16_t, struct SPI_TxRxDataLinkTypeDef*);
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>

                %openfile SPI_Buf
                /*******************************************************************************
                * Function Name  : %<SPIx>_CopyDataFcnSendRcv
                * Description    : %<SPIx> copy msg to send to ring buffer (if possible)
                * Input          : pointer to data to send , lengh(number) of data to send and
                *                  ring buffer info
                *******************************************************************************/
                void  %<SPIx>_CopyDataFcnSendRcv(uint8_t* ptSrc, uint16_t DataLength, struct SPI_TxRxDataLinkTypeDef* ptInfo)
                {    
                    uint16_t L_sizeMsg;
                    uint16_t L_idx;
                    /* Copy msg to send to ring buffer */
                    L_sizeMsg = 0;
                    for(L_idx=0;L_idx<DataLength;L_idx++){
                        if((uint32_t)ptInfo->pt_Tx_R >= (uint32_t)ptInfo->pt_EndTx_Buff)
                        {
                             ptInfo->pt_Tx_R = ptInfo->pt_StartTx_Buff;
                        }

                        if((((uint32_t)ptInfo->pt_Tx_W == (uint32_t)ptInfo->pt_Tx_R)&&ptInfo->nb2Send!=0))
                            break; //Ring Buffer is full.                        
                        *(char*)ptInfo->pt_Tx_W++ = *(char*)ptSrc++;
                        L_sizeMsg++;
                        if(ptInfo->pt_Tx_W == ptInfo->pt_Tx_R)
                            break; //Ring Buffer is full.  
                        if(ptInfo->pt_Tx_W == ptInfo->pt_EndTx_Buff){
                            //Revolve buffer
                            ptInfo->pt_Tx_W = ptInfo->pt_StartTx_Buff;
                        }
                    }
                    /* update nb of data to send */
                    ptInfo->txrxLock = 1; //Access locked
                    ptInfo->nb2Send += L_sizeMsg;
                    if(ptInfo->txrxLock == 2)
                        ptInfo->nb2Send -=  ptInfo->nbSent;
                    ptInfo->txrxLock = 0; //Unlock access 
                    if(L_sizeMsg < DataLength)
                        ptInfo->nbMsgLost++; //Message not all sent 
                    
                }  		
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)>
            %endif

            %if !EXISTS(::%<SPIx>_SendDataFcn)
                %assign ::%<SPIx>_SendDataFcn  = TLC_TRUE
                %openfile SPI_Buf
                /* %<SPIx>_SendReceiveDataFcn prototyping */
                void %<SPIx>_SendReceiveDataFcn(struct SPI_TxRxDataLinkTypeDef*);
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>

                %openfile SPI_Buf
                /*******************************************************************************
                * Function Name  : %<SPIx>_SendReceiveDataFcn
                * Description    : %<SPIx> Send ring buffer management
                * Input          : Ring buffer info
                *******************************************************************************/
                void  %<SPIx>_SendReceiveDataFcn(struct SPI_TxRxDataLinkTypeDef* ptInfo)
                {    
                     uint16_t L_sizeMsg;
                    uint16_t L_idx;
                    /* If SPI is not already running and data to send */
                    if(ptInfo->txrxStatus != SPI_TX_RX_ON && ptInfo->nb2Send) {
                        ptInfo->txrxStatus = SPI_TX_RX_ON;
                        if((uint32_t)ptInfo->pt_Tx_R < (uint32_t)ptInfo->pt_Tx_W){
                          L_sizeMsg = (uint32_t)ptInfo->pt_EndTx_Buff - (uint32_t)ptInfo->pt_Tx_R;
                        }
                        if((uint32_t)ptInfo->pt_Tx_R >= (uint32_t)ptInfo->pt_Tx_W)
                        {
                          L_sizeMsg = ((uint32_t)ptInfo->pt_EndTx_Buff - (uint32_t)ptInfo->pt_Tx_R)+((uint32_t)ptInfo->pt_Tx_W - (uint32_t)ptInfo->pt_StartTx_Buff);
                        }
                        /* Send all msg or end of ring buffer */
                        if(ptInfo->nb2Send <= L_sizeMsg) {
                            ptInfo->nbSent = ptInfo->nb2Send;
                            ptInfo->nbRcv = ptInfo->nb2Rcv;
                        %if (ISEQUAL(SPI_Mode, "IT_DMA_TX")||ISEQUAL(SPI_Mode,"DMA_TX")||ISEQUAL(SPI_Mode, "IT_DMA_RX_TX")||ISEQUAL(SPI_Mode, "DMA_RX_TX"))
                                /* %<SPIx> DMA send mode*/
                             if((uint32_t)ptInfo->pt_Tx_R < (uint32_t)ptInfo->pt_Tx_W){
                              HAL_SPI_TransmitReceive_DMA(&hspi%<SPINum>, ptInfo->pt_Tx_R,ptInfo->ptRcv, ptInfo->nb2Send);
                            }
                            if((uint32_t)ptInfo->pt_Tx_R >= (uint32_t)ptInfo->pt_Tx_W)
                            {
                              HAL_SPI_TransmitReceive_DMA(&hspi%<SPINum>, ptInfo->pt_Tx_R,ptInfo->ptRcv, (uint32_t)ptInfo->pt_EndTx_Buff - (uint32_t)ptInfo->pt_Tx_R);
                              HAL_SPI_TransmitReceive_DMA(&hspi%<SPINum>, ptInfo->pt_StartTx_Buff,ptInfo->ptRcv+(uint32_t)(ptInfo->pt_EndTx_Buff - (uint32_t)ptInfo->pt_Tx_R), (uint32_t)ptInfo->pt_Tx_W - (uint32_t)ptInfo->pt_StartTx_Buff);
                              
                            }
				
                        %elseif (ISEQUAL(SPI_Mode, "IT"))
                                /* %<SPIx> interrupt send mode*/

                             if((uint32_t)ptInfo->pt_Tx_R < (uint32_t)ptInfo->pt_Tx_W){
                                HAL_SPI_TransmitReceive_IT(&hspi%<SPINum>, ptInfo->pt_Tx_R,ptInfo->ptRcv, ptInfo->nb2Send);
                            }
                              if((uint32_t)ptInfo->pt_Tx_R >= (uint32_t)ptInfo->pt_Tx_W)
                            {
                                 HAL_SPI_TransmitReceive_IT(&hspi%<SPINum>, ptInfo->pt_Tx_R,ptInfo->ptRcv, (uint32_t)ptInfo->pt_EndTx_Buff - (uint32_t)ptInfo->pt_Tx_R);
                                 HAL_SPI_TransmitReceive_IT(&hspi%<SPINum>, ptInfo->pt_Tx_R,ptInfo->ptRcv+(uint32_t)(ptInfo->pt_EndTx_Buff - (uint32_t)ptInfo->pt_Tx_R), (uint32_t)ptInfo->pt_Tx_W - (uint32_t)ptInfo->pt_StartTx_Buff);
                                
                            }
                            
                        %else 
                                /* %<SPIx> pooling send mode*/
                             if((uint32_t)ptInfo->pt_Tx_R < (uint32_t)ptInfo->pt_Tx_W){
                                HAL_SPI_TransmitReceive(&hspi%<SPINum>, ptInfo->pt_Tx_R,ptInfo->ptRcv, ptInfo->nb2Send, G_%<SPIx>_TxRxPollTimeOut);
                            }
                            if((uint32_t)ptInfo->pt_Tx_R >= (uint32_t)ptInfo->pt_Tx_W)
                            {
                                HAL_SPI_TransmitReceive(&hspi%<SPINum>, ptInfo->pt_Tx_R,ptInfo->ptRcv, (uint32_t)ptInfo->pt_EndTx_Buff - (uint32_t)ptInfo->pt_Tx_R, G_%<SPIx>_TxRxPollTimeOut);
                                HAL_SPI_TransmitReceive(&hspi%<SPINum>, ptInfo->pt_StartTx_Buff,ptInfo->ptRcv+(uint32_t)(ptInfo->pt_EndTx_Buff - (uint32_t)ptInfo->pt_Tx_R), (uint32_t)ptInfo->pt_Tx_W - (uint32_t)ptInfo->pt_StartTx_Buff, G_%<SPIx>_TxRxPollTimeOut);
                            }
                            %if(ISEQUAL(NSS, "on"))
                                __HAL_SPI_DISABLE(&hspi%<SPINum>);
                            %endif
                        %endif
                        
                
                            for(L_idx=0;L_idx < ptInfo->nb2Send;L_idx++) {
                                ptInfo->pt_Tx_R++;
                                if((uint32_t)ptInfo->pt_Tx_R >= (uint32_t)ptInfo->pt_EndTx_Buff)
                                {
                                     ptInfo->pt_Tx_R = ptInfo->pt_StartTx_Buff;
                                }
                           }
                            ptInfo->nb2Send=0;
                        }
                        ptInfo->txrxStatus = SPI_TX_RX_OFF;
                    }
                  }
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)>
            %endif

        %endif
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************

%%*************************************************************************
		%% Initialization is defined once only per SPI transmission
%%*************************************************************************
        %if(ISEQUAL(Type_SPI, "Transmit_Only"))

            %if !EXISTS(::%<SPIx>_TX_poll)
                %assign ::%<SPIx>_TX_poll  = TLC_TRUE
                %openfile SPI_Buf
                    %if (ISEQUAL(SPI_Mode, "POLLING")||ISEQUAL(SPI_Mode, "DMA_RX")|| ISEQUAL(SPI_Mode, "IT_DMA_RX"))
                        /* %<SPIx> Tx polling timeout value. Number of Solver loop. (can be changed)*/
                        uint32_t G_%<SPIx>_TxPollTimeOut = 10;
                    %endif				
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Definitions",SPI_Buf)>
            

                %openfile SPI_Buf
                    %if (ISEQUAL(SPI_Mode, "POLLING")||ISEQUAL(SPI_Mode, "DMA_RX")|| ISEQUAL(SPI_Mode, "IT_DMA_RX"))
                        /* %<SPIx> Tx polling timeout value. Number of Solver loop. (can be changed)*/
                        extern uint32_t G_%<SPIx>_TxPollTimeOut;
                    %endif				
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>
            %endif

            %if !EXISTS(::%<SPIx>_TX_INIT)
                %assign ::%<SPIx>_TX_INIT  = TLC_TRUE
                %openfile SPI_Buf
                /* %<SPIx>_Tx_Initialization prototyping */
                void %<SPIx>_Tx_Initialization(void);
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>

                %openfile SPI_Buf
                /*******************************************************************************
                * Function Name  : %<SPIx>_Tx_Initialization
                * Description    : Send Initialization of %<SPIx>
                * Input          : -
                *******************************************************************************/
                void %<SPIx>_Tx_Initialization(void)
                {
                %if(%<SPINombre> > 1)						
                    /*Store %<SPIx> send data information and its handler */ 
                    G_SPI_TxData[G_NbSPITxConf] = &%<SPIx>_TxDataLink;
                    G_SPI_TxHandler[G_NbSPITxConf] = (void*)&hspi%<SPINum>;
                    G_NbSPITxConf++; /*Inc number of configured SPI for send*/
                %else
                    /*Store %<SPIx> send data information and its handler */ 
                    G_SPI_TxData = &%<SPIx>_TxDataLink;
                    G_SPI_TxHandler = (void*)&hspi%<SPINum>;
                %endif
                    /* Initialize ring buffer information */
                    %<SPIx>_TxDataLink.nb2Send = 0;   
                    %<SPIx>_TxDataLink.nbSent = 0;   
                    %<SPIx>_TxDataLink.nbMsgLost = 0;   
                    %<SPIx>_TxDataLink.bufferSize = %<Buffer_Send>;
                    %<SPIx>_TxDataLink.pt_StartTx_Buff = G_%<SPIx>_TxDataBuffer;
                    %<SPIx>_TxDataLink.pt_EndTx_Buff = &G_%<SPIx>_TxDataBuffer[%<Buffer_Send>];
                    %<SPIx>_TxDataLink.pt_Tx_W = G_%<SPIx>_TxDataBuffer;
                    %<SPIx>_TxDataLink.pt_Tx_R = G_%<SPIx>_TxDataBuffer;
                    %<SPIx>_TxDataLink.CopyDataFcn = %<SPIx>_CopyDataFcn;  
                    %<SPIx>_TxDataLink.SendDataFcn = %<SPIx>_SendDataFcn;  
                    %<SPIx>_TxDataLink.txStatus =  SPI_TX_OFF;
                    %<SPIx>_TxDataLink.txLock = 0;
                }  		
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)>
            %endif

            %if !EXISTS(::%<SPIx>_CopyDataFcn)
                %assign ::%<SPIx>_CopyDataFcn  = TLC_TRUE
                %openfile SPI_Buf
                /* %<SPIx>_CopyDataFcn prototyping */
                void %<SPIx>_CopyDataFcn(uint8_t*,uint16_t, struct SPI_TxDataLinkTypeDef*);
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>

                %openfile SPI_Buf
                /*******************************************************************************
                * Function Name  : %<SPIx>_CopyDataFcn
                * Description    : %<SPIx> copy msg to send to ring buffer (if possible)
                * Input          : pointer to data to send , lengh(number) of data to send and
                *                  ring buffer info
                *******************************************************************************/
                void  %<SPIx>_CopyDataFcn(uint8_t* ptSrc, uint16_t DataLength, struct SPI_TxDataLinkTypeDef* ptInfo)
                {    
                    uint16_t L_sizeMsg;
                    uint16_t L_idx;
                    /* Copy msg to send to ring buffer */
                    L_sizeMsg = 0;
                    for(L_idx=0;L_idx<DataLength;L_idx++){
                        if((uint32_t)ptInfo->pt_Tx_R >= (uint32_t)ptInfo->pt_EndTx_Buff)
                        {
                             ptInfo->pt_Tx_R = ptInfo->pt_StartTx_Buff;
                        }

                        if((((uint32_t)ptInfo->pt_Tx_W == (uint32_t)ptInfo->pt_Tx_R)&&ptInfo->nb2Send!=0))
                            break; //Ring Buffer is full.                        
                        *(char*)ptInfo->pt_Tx_W++ = *(char*)ptSrc++;
                        L_sizeMsg++;
                        if(ptInfo->pt_Tx_W == ptInfo->pt_Tx_R)
                            break; //Ring Buffer is full.  
                        if(ptInfo->pt_Tx_W == ptInfo->pt_EndTx_Buff){
                            //Revolve buffer
                            ptInfo->pt_Tx_W = ptInfo->pt_StartTx_Buff;
                        }
                    }
                    /* update nb of data to send */
                    ptInfo->txLock = 1; //Access locked
                    ptInfo->nb2Send += L_sizeMsg;
                    if(ptInfo->txLock == 2)
                        ptInfo->nb2Send -=  ptInfo->nbSent;
                    ptInfo->txLock = 0; //Unlock access 
                    if(L_sizeMsg < DataLength)
                        ptInfo->nbMsgLost++; //Message not all sent 
                   
                }  		
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)>
            %endif

            %if !EXISTS(::%<SPIx>_SendDataFcn)
                %assign ::%<SPIx>_SendDataFcn  = TLC_TRUE
                %openfile SPI_Buf
                /* %<SPIx>_SendDataFcn prototyping */
                void %<SPIx>_SendDataFcn(struct SPI_TxDataLinkTypeDef*);
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>

                %openfile SPI_Buf
                /*******************************************************************************
                * Function Name  : %<SPIx>_SendDataFcn
                * Description    : %<SPIx> Send ring buffer management
                * Input          : Ring buffer info
                *******************************************************************************/
                void  %<SPIx>_SendDataFcn(struct SPI_TxDataLinkTypeDef* ptInfo)
                {    
                     uint16_t L_sizeMsg;
                    uint16_t L_idx;
                    /* If SPI is not already running and data to send */
                    if(ptInfo->txStatus != SPI_TX_ON && ptInfo->nb2Send) {
                        ptInfo->txStatus = SPI_TX_ON;
                        if((uint32_t)ptInfo->pt_Tx_R < (uint32_t)ptInfo->pt_Tx_W){
                          L_sizeMsg = (uint32_t)ptInfo->pt_EndTx_Buff - (uint32_t)ptInfo->pt_Tx_R;
                        }
                        if((uint32_t)ptInfo->pt_Tx_R >= (uint32_t)ptInfo->pt_Tx_W)
                        {
                          L_sizeMsg = ((uint32_t)ptInfo->pt_EndTx_Buff - (uint32_t)ptInfo->pt_Tx_R)+((uint32_t)ptInfo->pt_Tx_W - (uint32_t)ptInfo->pt_StartTx_Buff);
                        }
                        /* Send all msg or end of ring buffer */
                        if(ptInfo->nb2Send <= L_sizeMsg) {
                            ptInfo->nbSent = ptInfo->nb2Send;
                        %if (ISEQUAL(SPI_Mode, "IT_DMA_TX")||ISEQUAL(SPI_Mode,"DMA_TX")||ISEQUAL(SPI_Mode, "IT_DMA_RX_TX")||ISEQUAL(SPI_Mode, "DMA_RX_TX"))
                                /* %<SPIx> DMA send mode*/
                             if((uint32_t)ptInfo->pt_Tx_R < (uint32_t)ptInfo->pt_Tx_W){
                              HAL_SPI_Transmit_DMA(&hspi%<SPINum>, ptInfo->pt_Tx_R, ptInfo->nb2Send);
                            }
                            if((uint32_t)ptInfo->pt_Tx_R >= (uint32_t)ptInfo->pt_Tx_W)
                            {
                              HAL_SPI_Transmit_DMA(&hspi%<SPINum>, ptInfo->pt_Tx_R, (uint32_t)ptInfo->pt_EndTx_Buff - (uint32_t)ptInfo->pt_Tx_R);
                              HAL_SPI_Transmit_DMA(&hspi%<SPINum>, ptInfo->pt_Tx_R, (uint32_t)ptInfo->pt_Tx_W - (uint32_t)ptInfo->pt_StartTx_Buff);
                            }
                            

				
                        %elseif (ISEQUAL(SPI_Mode, "IT"))
                                /* %<SPIx> interrupt send mode*/

                             if((uint32_t)ptInfo->pt_Tx_R < (uint32_t)ptInfo->pt_Tx_W){
                                HAL_SPI_Transmit_IT(&hspi%<SPINum>, ptInfo->pt_Tx_R, ptInfo->nb2Send);
                            }
                              if((uint32_t)ptInfo->pt_Tx_R >= (uint32_t)ptInfo->pt_Tx_W)
                            {
                                 HAL_SPI_Transmit_IT(&hspi%<SPINum>, ptInfo->pt_Tx_R, (uint32_t)ptInfo->pt_EndTx_Buff - (uint32_t)ptInfo->pt_Tx_R);
                                 HAL_SPI_Transmit_IT(&hspi%<SPINum>, ptInfo->pt_Tx_R, (uint32_t)ptInfo->pt_Tx_W - (uint32_t)ptInfo->pt_StartTx_Buff);
                            }

                        %else 
                                /* %<SPIx> pooling send mode*/
                             if((uint32_t)ptInfo->pt_Tx_R < (uint32_t)ptInfo->pt_Tx_W){
                                HAL_SPI_Transmit(&hspi%<SPINum>, ptInfo->pt_Tx_R, ptInfo->nb2Send, G_%<SPIx>_TxPollTimeOut);
                            }
                            if((uint32_t)ptInfo->pt_Tx_R >= (uint32_t)ptInfo->pt_Tx_W)
                            {
                                HAL_SPI_Transmit(&hspi%<SPINum>, ptInfo->pt_Tx_R, (uint32_t)ptInfo->pt_EndTx_Buff - (uint32_t)ptInfo->pt_Tx_R, G_%<SPIx>_TxPollTimeOut);
                                HAL_SPI_Transmit(&hspi%<SPINum>, ptInfo->pt_StartTx_Buff, (uint32_t)ptInfo->pt_Tx_W - (uint32_t)ptInfo->pt_StartTx_Buff, G_%<SPIx>_TxPollTimeOut);
                            }
                            %if(ISEQUAL(NSS, "on"))
                                __HAL_SPI_DISABLE(&hspi%<SPINum>);
                            %endif
                        %endif
                        
                
                            for(L_idx=0;L_idx < ptInfo->nb2Send;L_idx++) {
                                ptInfo->pt_Tx_R++;
                                if((uint32_t)ptInfo->pt_Tx_R >= (uint32_t)ptInfo->pt_EndTx_Buff)
                                {
                                     ptInfo->pt_Tx_R = ptInfo->pt_StartTx_Buff;
                                }
                           }
                            ptInfo->nb2Send=0;
                        }
                        ptInfo->txStatus = SPI_TX_OFF;
                    }
                  }
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)>
            %endif
        %endif
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
    %% *************************************************************************************
    %% definition of the receipt size buffer
    %% *************************************************************************************
        %if(ISEQUAL(Type_SPI, "Receive_Only"))

            	

           %if EXISTS(::InsertRxSPI_buffer) && (::InsertRxSPI_buffer == TLC_TRUE)
                %assign ::InsertRxSPI_buffer    = TLC_FALSE
                %openfile SPI_Buf
                    /* %<SPIx> Receive data buffer  %<Type_SPI>*/
                    uint8_t G_%<SPIx>_RxDataBuffer[%<Buffer_Rcv>];	
                    /* %<SPIx> receive data structure information*/
                    struct SPI_RxDataLinkTypeDef   %<SPIx>_RxDataLink;		
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Defines",SPI_Buf)>

                 %openfile SPI_Buf
                    /* %<SPIx> handler */
                    extern SPI_HandleTypeDef hspi%<SPINum>;
                    %%test for DMA handler
                    %if (ISEQUAL(SPI_Mode, "IT_DMA_RX")||ISEQUAL(SPI_Mode, "DMA_RX")||ISEQUAL(SPI_Mode, "IT_DMA_RX_TX")||ISEQUAL(SPI_Mode, "DMA_RX_TX"))
                        extern DMA_HandleTypeDef hdma_SPI%<SPINum>_rx;
                    %endif

                    /* %<SPIx> Receive data buffer*/
                    extern uint8_t G_%<SPIx>_RxDataBuffer[];	
                    /* %<SPIx> Receive data structure information*/
                    extern struct SPI_RxDataLinkTypeDef   %<SPIx>_RxDataLink;								
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>
            %endif



            %% Initialization is defined once only per SPI
            %if !EXISTS(::%<SPIx>_RX_INIT)
                    %assign ::%<SPIx>_RX_INIT  = TLC_TRUE				
                %openfile SPI_Buf
                    /* %<SPIx>_Rx_Initialization prototyping */
                    void %<SPIx>_Rx_Initialization(void);
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>

                %openfile SPI_Buf
                    /*******************************************************************************
                    * Function Name  : %<SPIx>_Rx_Initialization
                    * Description    : Receive Initialization of %<SPIx>
                    * Input          : -
                    *******************************************************************************/
                    void %<SPIx>_Rx_Initialization(void)
                    {
                    %if(%<SPINombre> > 1)						
                        /*Store %<SPIx> receive data information and its handler */ 
                        G_SPI_RxData[G_NbSPIRxConf] = &%<SPIx>_RxDataLink;
                        G_SPI_RxHandler[G_NbSPIRxConf] = (void*)&hspi%<SPINum>;
                        G_NbSPIRxConf++; /*Inc number of configured USART for receive*/
                    %else
                        /*Store %<SPIx> receive data information and its handler */ 
                        G_SPI_RxData = &%<SPIx>_RxDataLink;
                            G_SPI_RxHandler = (void*)&hspi%<SPINum>;
                    %endif
                        %<SPIx>_RxDataLink.ptRcv =  G_%<SPIx>_RxDataBuffer;
                        %<SPIx>_RxDataLink.rxStatus =  SPI_RX_OFF;						
                    }  		
                %closefile SPI_Buf
                %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)>
            %endif
        %endif
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************
 %% ****************************************************************************************************************************************************



    %endfunction
%else
%% ERROR SPI RCV INIT MUST BE CALLED ONCE ONLY 
   %trace ERROR SPI INIT MUST BE CALLED ONCE ONLY 
%endif 

%% *************************************************************************************
%% ******************      Fonction Outputs        *************************************
%% *************************************************************************************


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%fonction output faite une seule fois aussi
%% il permet de créé les différentes entrées et sorties nécéssaires 
%% Function: Outputs ==========================================
%% Abstract:
%% SPI input value depending on pin config
%%
    %function Outputs(block, system) Output
        %%model.c and model.h files
        %assign SrcBaseName = LibGetMdlSrcBaseName()
        %%model_SPI.h and model_SPI.c files
        %assign SrcBaseName_SPI = "%<SrcBaseName>_SPI"
        %assign modelH_SPI      = LibCreateSourceFile("Header", "Simulink", SrcBaseName_SPI)
        %assign modelC_SPI      = LibCreateSourceFile("Source", "Simulink", SrcBaseName_SPI)

        %assign SPIx =  SFcnParamSettings.SPIx
        %assign Device_Mode =  SFcnParamSettings.Device_Mode
        %assign Type_SPI =  SFcnParamSettings.Type_SPI
		%assign SPI_Mode = SFcnParamSettings.SPI_Mode
        %assign Handler =  SFcnParamSettings.Handler	
        %assign Buffer_Size_Rcv = SFcnParamSettings.Buffer_Size_Rcv
        %assign Buffer_Size_Send = SFcnParamSettings.Buffer_Size_Send	
        %assign NbSPI = SFcnParamSettings.NbSPI
		%assign Timeout = SFcnParamSettings.TimeoutValue
		%assign Error = SFcnParamSettings.Error
		%assign CallBack = SFcnParamSettings.CallBack
		%assign Transmission = SFcnParamSettings.Transmission
		%assign block_name =  block.Identifier	
		
		%if !EXISTS(::InsertIdxSPI)
			%assign ::InsertIdxSPI  = TLC_TRUE		
            %openfile SPI_Buf
                uint16_t L_idx;
            %closefile SPI_Buf
            %<LibSystemOutputCustomCode(system,SPI_Buf,"declaration")>		
        %endif		
		
        %assign CallBack = SFcnParamSettings.CallBack
       %% %assign IRQ_TX = SFcnParamSettings.IRQ_TX
		
		%assign SPINum = IDNUM("%<SPIx>")[1]
        %assign SPINombre=IDNUM("%<NbSPI>")[1]
 	    %assign InputNum = 0


      %%definition of block ports
        %if(ISEQUAL(Type_SPI, "Receive_Only"))
            %if(ISEQUAL(Error, "on")||ISEQUAL(CallBack, "on")||ISEQUAL(Transmission, "on"))
                %assign NbRcv = LibBlockOutputSignal(1, "", "", 0)
            %else
                %assign NbRcv = LibBlockOutputSignal(0, "", "", 0)
            %endif
            
            %assign dataRcv = LibBlockOutputSignalAddr(1, "", "", 0)
            
            %assign Nb2Rcv = LibBlockInputSignal(0, "", "", 0)
            
        %endif
        %if(ISEQUAL(Type_SPI, "Transmit_Only"))
            %if(ISEQUAL(Error, "on")||ISEQUAL(CallBack, "on")||ISEQUAL(Transmission, "on"))
                %assign NbSend = LibBlockOutputSignal(1, "", "", 0)
            %else
                %assign NbSend = LibBlockOutputSignal(0, "", "", 0)
            %endif
            
            %assign Nb2Send = LibBlockInputSignal(0, "", "", 0)
            %assign DataSend = LibBlockInputSignal(1, "", "", 0)
        %endif
        %if(ISEQUAL(Type_SPI, "Full_Duplex"))
            %if(ISEQUAL(Error, "on")||ISEQUAL(CallBack, "on")||ISEQUAL(Transmission, "on"))
                %assign NbSend = LibBlockOutputSignal(1, "", "", 0)
                
                %assign dataRcv = LibBlockOutputSignalAddr(2, "", "", 0)
            %else
                %assign NbSend = LibBlockOutputSignal(0, "", "", 0)
               
                %assign dataRcv = LibBlockOutputSignalAddr(1, "", "", 0)
            %endif
            
          
            %assign Nb2Send = LibBlockInputSignal(0, "", "", 0)
            %assign DataSend = LibBlockInputSignal(1, "", "", 0)
        %endif

        %if(ISEQUAL(Type_SPI, "Half_Duplex"))
            
            %if(ISEQUAL(Error, "on")||ISEQUAL(CallBack, "on")||ISEQUAL(Transmission, "on"))
                %assign NbSend = LibBlockOutputSignal(1, "", "", 0)
                
                %assign dataRcv = LibBlockOutputSignalAddr(2, "", "", 0)
            %else
                %assign NbSend = LibBlockOutputSignal(0, "", "", 0)
                
                %assign dataRcv = LibBlockOutputSignalAddr(1, "", "", 0)
            %endif
            
            
            %assign Nb2Send = LibBlockInputSignal(0, "", "", 0)
            %assign DataSend = LibBlockInputSignal(1, "", "", 0)
        %endif

        %assign Buffer_Send=IDNUM("%<Buffer_Size_Send>")[1]
        %assign Buffer_Rcv=IDNUM("%<Buffer_Size_Rcv>")[1]	
       
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		%if(ISEQUAL(Transmission, "on"))
			ItTransmissionTxFcn = %<block_name>_Transmission_Handler; 
		%else
            %if EXISTS(::Create_R_Transmission_FCN) && (::Create_R_Transmission_FCN == TLC_FALSE)		
                ItTransmissionTxFcn = NULL;
            %endif			
		%endif
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


        %if(ISEQUAL(CallBack, "on"))
			ItCallBackRxFcn = %<block_name>_CallBack_Handler; 
		%else
            %if EXISTS(::Create_R_CallBack_FCN) && (::Create_R_CallBack_FCN == TLC_FALSE)		
                ItCallBackRxFcn = NULL;
            %endif			
		%endif
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        %if(ISEQUAL(Error, "on"))
            ItErrorFcn = %<block_name>_Error_Handler; 
		%else
            %if EXISTS(::Create_R_CALLBACK_FCN) && (::Create_R_CALLBACK_FCN == TLC_FALSE)		
                ItErrorFcn = NULL;
            %endif			
		%endif
			
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        %if(ISEQUAL(Type_SPI, "Full_Duplex")||ISEQUAL(Type_SPI, "Half_Duplex"))
            if(%<Nb2Send> != 0)
		{
            /* Wait for end of current send data*/ 
            while(%<SPIx>_TxRxDataLink.txrxStatus == SPI_TX_RX_ON);
            /* Copy data to send */
            %<SPIx>_CopyDataFcnSendRcv((uint8_t*)%<DataSend>, (uint16_t)%<Nb2Send>, &%<SPIx>_TxRxDataLink);
        }


        if(hspi%<SPINum>.State == HAL_SPI_STATE_READY)
		{
			%<NbSend> = 0;
            %<SPIx>_SendReceiveDataFcn(&%<SPIx>_TxRxDataLink);
		}
         
         *(%<dataRcv>) =  (uint32_T)G_%<SPIx>_TxRxDataRcvBuffer;    
        %endif

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        %if(ISEQUAL(Type_SPI, "Transmit_Only"))
            if(%<Nb2Send> != 0)
		{
            /* Wait for end of current send data*/ 
            while(%<SPIx>_TxDataLink.txStatus == SPI_TX_ON);
            /* Copy data to send */
            %<SPIx>_CopyDataFcn((uint8_t*)%<DataSend>, (uint16_t)%<Nb2Send>, &%<SPIx>_TxDataLink);
        }


        if(hspi%<SPINum>.State == HAL_SPI_STATE_READY)
		{
			%<NbSend> = 0;
            %<SPIx>_SendDataFcn(&%<SPIx>_TxDataLink);
		}
            
        %endif
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        %if(ISEQUAL(Type_SPI, "Receive_Only"))
           
            %openfile SPI_Buf
                %if (ISEQUAL(SPI_Mode, "POLLING")||ISEQUAL(SPI_Mode, "DMA_TX")|| ISEQUAL(SPI_Mode, "IT_DMA_TX"))
                    /* %<SPIx> Rx polling timeout value. Number of Solver loop. (can be changed)*/
                    uint32_t G_%<SPIx>_RxPollTimeOut = 10;
                %endif				
            %closefile SPI_Buf
            %<LibSetSourceFileSection(modelC_SPI,"Definitions",SPI_Buf)>	

            %openfile SPI_Buf
                %if (ISEQUAL(SPI_Mode, "POLLING")||ISEQUAL(SPI_Mode, "DMA_TX")|| ISEQUAL(SPI_Mode, "IT_DMA_TX"))
                    /* %<SPIx> Rx polling timeout value. Number of Solver loop. (can be changed)*/
                    extern uint32_t G_%<SPIx>_RxPollTimeOut;
                %endif				
            %closefile SPI_Buf
            %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>

             %openfile SPI_Buf
            if(%<SPIx>_RxDataLink.rxStatus == SPI_RX_OFF)
            {


                %<SPIx>_RxDataLink.ptRcv =  G_%<SPIx>_RxDataBuffer;
                %<NbRcv> = 0;
                %if (ISEQUAL(SPI_Mode, "DMA_RX")|| ISEQUAL(SPI_Mode, "IT_DMA_RX")||ISEQUAL(SPI_Mode, "IT_DMA_RX_TX"))
                %<SPIx>_RxDataLink.rxStatus = SPI_RX_ON;
                /* %<SPIx> DMA receive mode*/
                HAL_SPI_Receive_DMA(&hspi%<SPINum>, G_%<SPIx>_RxDataBuffer, %<Nb2Rcv>);%%HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);			
                %elseif ( ISEQUAL(SPI_Mode, "IT"))
                %<SPIx>_RxDataLink.rxStatus = SPI_RX_ON;
                /* %<SPIx> interrupt receive mode*/
                HAL_SPI_Receive_IT(&hspi%<SPINum>, G_%<SPIx>_RxDataBuffer, %<Nb2Rcv>);%% HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size);
                %else 
                /* %<SPIx> pooling receive mode*/
                HAL_SPI_Receive(&hspi%<SPINum>, G_%<SPIx>_RxDataBuffer, %<Nb2Rcv>, G_%<SPIx>_RxPollTimeOut);%%HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);
                %<SPIx>_RxDataLink.rxStatus = SPI_RX_OK;
                %endif
            }

            if(%<SPIx>_RxDataLink.rxStatus == SPI_RX_OK){
                %<NbRcv> = %<Nb2Rcv>;
                for(L_idx=0; L_idx<%<Nb2Rcv>; L_idx++) {
                    *(char*)(%<dataRcv>+L_idx) = *(char*)%<SPIx>_RxDataLink.ptRcv++;
                }
                G_%<SPIx>_RxDataBuffer[L_idx] = 0;		
                %<SPIx>_RxDataLink.rxStatus = SPI_RX_OFF;	
            }
            %closefile SPI_Buf
            %<LibSystemOutputCustomCode(system,SPI_Buf,"execution")>
        %endif
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %if(ISEQUAL(Error, "on"))
            %openfile SPI_Buf
			/* %<block_name>_Error_Handler prototype */				
			void %<block_name>_Error_Handler(void);			
            %closefile SPI_Buf
            %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>

            %openfile SPI_Buf
            /*******************************************************************************
            * Function Name  : %<block_name>_Error_Handler
            * Description    : Handler for SPI Timeout error
            * Input          : None
            *******************************************************************************/
            void %<block_name>_Error_Handler()
            {
                    %foreach callIdx = NumSFcnSysOutputCalls
                        %if (ISEQUAL(callIdx, 0))				
        					%if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall,"unconnected")
                				%assign wrnTxt = "No code will be generated for Read Error  "\
                        		"since it is not connected to a system."
                                %<LibReportWarning(wrnTxt)>
        						%continue
                			%endif
                        	%% call the downstream system
        					%<LibBlockExecuteFcnCall(block, callIdx)>\
                		%endif
                    %endforeach
			}			
            %closefile SPI_Buf
            %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)>	
        %endif		
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		%if(ISEQUAL(CallBack, "on"))
           %openfile SPI_Buf
			/* %<block_name>_CallBack_Handler prototype */				
			extern void %<block_name>_CallBack_Handler(void);			
            %closefile SPI_Buf
            %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>

            %openfile SPI_Buf
            /*******************************************************************************
            * Function Name  : %<block_name>_CallBack_Handler
            * Description    : Function called from SPI read complete callback
            * Input          : None
            *******************************************************************************/
            void %<block_name>_CallBack_Handler()
            {
                    %foreach callIdx = NumSFcnSysOutputCalls
                        %if (ISEQUAL(Error,"off") && ISEQUAL(callIdx, 0))				
        					%if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall,"unconnected")
                				%assign wrnTxt = "No code will be generated for Read complete  "\
                        		"since it is not connected to a system."
                                %<LibReportWarning(wrnTxt)>
        						%continue
                			%endif
                        	%% call the downstream system
        					%<LibBlockExecuteFcnCall(block, callIdx)>\
                		%elseif  (ISEQUAL(Error,"on") && ISEQUAL(callIdx, 1))				
                        	%if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall,"unconnected")
                                %assign wrnTxt = "No code will be generated for Read complete  "\
        						"since it is not connected to a system."
                				%<LibReportWarning(wrnTxt)>
                        		%continue
        					%endif
                			%% call the downstream system
                        	%<LibBlockExecuteFcnCall(block, callIdx)>\
                		%endif
                    %endforeach
			}			
            %closefile SPI_Buf
            %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)>									
        %endif
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		%if(ISEQUAL(Transmission,"on"))
           %openfile SPI_Buf
			/* %<block_name>_Transmission_Handler prototype */				
			extern void %<block_name>_Transmission_Handler(void);			
            %closefile SPI_Buf
            %<LibSetSourceFileSection(modelH_SPI,"Defines",SPI_Buf)>

            %openfile SPI_Buf
            /*******************************************************************************
            * Function Name  : %<block_name>_Transmission_Handler
            * Description    : Function called from SPI read complete callback
            * Input          : None
            *******************************************************************************/
            void %<block_name>_Transmission_Handler()
            {
                    %foreach callIdx = NumSFcnSysOutputCalls
                        %if (ISEQUAL(Error,"off") && ISEQUAL(callIdx, 0)&&ISEQUAL(CallBack,"off"))				
        					%if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall,"unconnected")
                				%assign wrnTxt = "No code will be generated for Transmission complete  "\
                        		"since it is not connected to a system."
                                %<LibReportWarning(wrnTxt)>
        						%continue
                			%endif
                        	%% call the downstream system
        					%<LibBlockExecuteFcnCall(block, callIdx)>\
                		%elseif  (ISEQUAL(Error,"on") && ISEQUAL(callIdx, 1)&&ISEQUAL(CallBack,"off")||ISEQUAL(Error,"off") && ISEQUAL(callIdx, 1)&&ISEQUAL(CallBack,"on"))				
                        	%if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall,"unconnected")
                                %assign wrnTxt = "No code will be generated for Transmission complete  "\
        						"since it is not connected to a system."
                				%<LibReportWarning(wrnTxt)>
                        		%continue
        					%endif
                			%% call the downstream system
                        	%<LibBlockExecuteFcnCall(block, callIdx)>\
                        %elseif  (ISEQUAL(Error,"on") && ISEQUAL(callIdx, 2)&&ISEQUAL(CallBack,"on"))				
                        	%if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall,"unconnected")
                                %assign wrnTxt = "No code will be generated for Transmission complete  "\
        						"since it is not connected to a system."
                				%<LibReportWarning(wrnTxt)>
                        		%continue
        					%endif
                			%% call the downstream system
                        	%<LibBlockExecuteFcnCall(block, callIdx)>\
                		%endif
                    %endforeach
			}			
            %closefile SPI_Buf
            %<LibSetSourceFileSection(modelC_SPI,"Functions",SPI_Buf)>									
        %endif

   %endfunction
   
%% [EOF] SPI_Read.tlc