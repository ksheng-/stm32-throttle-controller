%% $RCSfile: ADC_Read.tlc,v $
%% $Revision: 2.1 $
%% $Date: 2014/05/26 $
%%
%% Abstract: ADC Read 
%%    STM32 ADC Read input value from ADCx.
%%    Generated code is based on STM32 HAL Library files.
%%
%% Copyright 1990-2009 The MathWorks, Inc.
%assign CodeFormat = "Embedded-C"
%implements ADC_Read "C"

%include "FunctionCalledAsChart.tlc"

%%warning "---------->Start ADC_READ"

%if !EXISTS(::CreateADC_Read)
    %assign ::CreateADC_Read  = TLC_TRUE
%endif

%if !EXISTS(::InsertIncludesToADC)
    %assign ::InsertIncludesToADC  = TLC_TRUE
%endif 

%if !EXISTS(::InsertIncludesFromADC)
    %assign ::InsertIncludesFromADC  = TLC_TRUE
%endif 

%if !EXISTS(::InsertADC)
    %assign ::InsertADC  = TLC_TRUE
%endif 

%if !EXISTS(::InsertItRegADC)
    %assign ::InsertItRegADC  = TLC_TRUE
%endif 

%if !EXISTS(::InsertDmaRegADC)
    %assign ::InsertDmaRegADC  = TLC_TRUE
%endif 

%if !EXISTS(::InsertItInjADC)
    %assign ::InsertItInjADC  = TLC_TRUE
%endif 

%if !EXISTS(::InsertAwdItADC)
    %assign ::InsertAwdItADC  = TLC_TRUE
%endif 

%if !EXISTS(::InsertOvrItADC)
    %assign ::InsertOvrItADC  = TLC_TRUE
%endif 

%assign ADC_Name =  SFcnParamSettings.ADC_Name

%if !EXISTS(::VarDef_%<ADC_Name>)
    %assign ::VarDef_%<ADC_Name>  = TLC_TRUE
%endif 

%if !EXISTS(::Initialization_%<ADC_Name>)
    %assign ::Initialization_%<ADC_Name>  = TLC_TRUE
%endif 

%if !EXISTS(::ItEOCFcn_%<ADC_Name>)
    %assign ::ItEOCFcn_%<ADC_Name>  = TLC_TRUE
%endif 
%if !EXISTS(::ItJEOCFcn_%<ADC_Name>)
    %assign ::ItJEOCFcn_%<ADC_Name>  = TLC_TRUE
%endif 
%if !EXISTS(::ItAWDFcn_%<ADC_Name>)
    %assign ::ItAWDFcn_%<ADC_Name>  = TLC_TRUE
%endif 
%if !EXISTS(::ItOVRFcn_%<ADC_Name>)
    %assign ::ItOVRFcn_%<ADC_Name>  = TLC_TRUE
%endif 


%assign ::CreateADC_Read  = TLC_TRUE

%trace CreateADC_Read  %<CreateADC_Read>


%% Create function for ADC Read:
%if EXISTS(CreateADC_Read) && (CreateADC_Read == TLC_TRUE)

    %%assign ::CreateADC_Read = TLC_FALSE

%% Code for system initialization:
    %function Start(block,system) Output
        %assign ADC_Name =  SFcnParamSettings.ADC_Name		
        %assign NbADC =  SFcnParamSettings.NbADC
		%assign DmaReq = SFcnParamSettings.DmaReq
		%assign ItReq = SFcnParamSettings.ItReq
		%assign ADC_RegNb = SFcnParamSettings.ADC_RegNb
		%assign ADC_InjNb = SFcnParamSettings.ADC_InjNb
		%assign ADC_NbTotCh = %<ADC_RegNb> + %<ADC_InjNb>
		%assign adcNum = IDNUM("%<ADC_Name>")[1]

		%assign AWD_Mode = SFcnParamSettings.AWD_Mode
		%assign AWD_Ch = SFcnParamSettings.AWD_Ch
		%assign AWD_HThres = SFcnParamSettings.AWD_HThres
		%assign AWD_LThres = SFcnParamSettings.AWD_LThres
		%assign AWD_En_Int = SFcnParamSettings.AWD_En_Int
		%assign EOC_SEQ = SFcnParamSettings.EOC_SEQ
		%assign EOC_IT = SFcnParamSettings.EOC_IT
		%assign JEOC_IT = SFcnParamSettings.JEOC_IT
		%assign AWD_IT = SFcnParamSettings.AWD_IT
		%assign OVR_IT = SFcnParamSettings.OVR_IT
		
    %if !EXISTS(::Initialization_%<ADC_Name>) || (::Initialization_%<ADC_Name> == TLC_TRUE)
        %assign ::Initialization_%<ADC_Name>    = TLC_FALSE		
        %openfile ADC_Buf
		/* %<ADC_Name> initialization */
			/*Store %<ADC_Name> data information and its handler */ 
		%if (%<NbADC> > 1)
			G_ADC_Data[G_NbAdcConf] = &%<ADC_Name>_DataLink;
			G_ADC_Handler[G_NbAdcConf] = &hadc%<adcNum>;
			G_NbAdcConf++; /*Inc number of configured ADC */
		%else
			G_ADC_Data = &%<ADC_Name>_DataLink;
			G_ADC_Handler = &hadc%<adcNum>;
		%endif	
        %if (%<ADC_RegNb> > 0)
            %<ADC_Name>_DataLink.RegularValueBuffer = %<ADC_Name>_RegularConvertedValue;
			%<ADC_Name>_DataLink.RegularCurrentRank = 0;
			%<ADC_Name>_DataLink.nbRegChannel = %<ADC_RegNb>;
		%else
            %<ADC_Name>_DataLink.RegularValueBuffer = NULL;
			%<ADC_Name>_DataLink.RegularCurrentRank = 0;
			%<ADC_Name>_DataLink.nbRegChannel = 0;
		%endif
        %if (%<ADC_InjNb> > 0)
		%if (ISEQUAL(DmaReq, "on")||ISEQUAL(ItReq, "on"))		
            %<ADC_Name>_DataLink.InjectedValueBuffer = %<ADC_Name>_InjectedConvertedValue;
		%endif
			%<ADC_Name>_DataLink.InjectedCurrentRank = ADC_INJECTED_RANK_1;
			%<ADC_Name>_DataLink.nbInjChannel = %<ADC_InjNb>;
		%else
            %<ADC_Name>_DataLink.InjectedValueBuffer = NULL;
			%<ADC_Name>_DataLink.InjectedCurrentRank = ADC_INJECTED_RANK_1;
			%<ADC_Name>_DataLink.nbInjChannel = 0;
		%endif
			/* Interrupt vector initialization */
			%<ADC_Name>_DataLink.ItEOCFcn = NULL;
			%<ADC_Name>_DataLink.ItJEOCFcn = NULL;
            %<ADC_Name>_DataLink.ItAWDFcn = NULL;
            %<ADC_Name>_DataLink.ItOVRFcn = NULL;
			
            /* Force data alignment to Right */
            hadc%<adcNum>.Init.DataAlign = ADC_DATAALIGN_RIGHT;		

        %if (ISEQUAL(DmaReq, "on"))
			/* DMA acquisition mode */
			%<ADC_Name>_DataLink.useDMA = true;
		%else
			/* DMA not used */
			%<ADC_Name>_DataLink.useDMA = false;
		%endif
        %if (ISEQUAL(EOC_SEQ, "on"))
			/* EOS/JEOS at end of all conversions */
			%<ADC_Name>_DataLink.IntEndOfAllConv = true;
		%else
			/* EOC/JEOC at end of single channel conversion */
			%<ADC_Name>_DataLink.IntEndOfAllConv = false;		
		%endif		
%%        %closefile ADC_Buf
%%		  %<LibMdlStartCustomCode(ADC_Buf,"execution")>;
%%        %openfile ADC_Buf		
        %if (ISEQUAL(DmaReq, "on"))
		    %if (%<ADC_RegNb> > 0)
            /* Start DMA conversion for %<ADC_Name> regular channel*/
            HAL_ADC_Start_DMA(&hadc%<adcNum>, (uint32_t*)&%<ADC_Name>_RegularConvertedValue, %<ADC_RegNb>);
			%endif
        %elseif (ISEQUAL(ItReq, "on"))
		    %if (%<ADC_RegNb> > 0)
            /* Start interrupt conversion for %<ADC_Name> regular channel*/
            HAL_ADC_Start_IT(&hadc%<adcNum>);
 			%endif
			%if (%<ADC_InjNb> > 0)
            /* Start interrupt conversion for %<ADC_Name> injected channel*/			
			HAL_ADCEx_InjectedStart_IT(&hadc%<adcNum>);
 			%endif
		%else
		    %if (%<ADC_RegNb> > 0)
			/* Start %<ADC_Name> conversion */
			HAL_ADC_Start(&hadc%<adcNum>);
 			%endif
			%if (%<ADC_InjNb> > 0)
            /* Start conversion for %<ADC_Name> injected channel*/			
			HAL_ADCEx_InjectedStart(&hadc%<adcNum>);
 			%endif		
        %endif
        %closefile ADC_Buf
		%<LibMdlStartCustomCode(ADC_Buf,"execution")>;
%%		%<LibMdlStartCustomCode(ADC_Buf,"trailer")>;
	%endif
		
        %openfile ADC_Buf		
        %if (ISEQUAL(EOC_IT, "on"))
            %if !EXISTS(::ItEOCFcn_%<ADC_Name>) || (::ItEOCFcn_%<ADC_Name> == TLC_TRUE)
            %assign ::ItEOCFcn_%<ADC_Name>    = TLC_FALSE		
            /* Update End of Conversion interrupt function */
            %<ADC_Name>_DataLink.ItEOCFcn = %<ADC_Name>_ItEOCFcn;
			%else
            %exit Multiple %<ADC_Name> ADC_Read block: Update End of Conversion interrupt already used. 
            %endif
        %endif
        %if (ISEQUAL(JEOC_IT, "on"))
            %if !EXISTS(::ItJEOCFcn_%<ADC_Name>) || (::ItJEOCFcn_%<ADC_Name> == TLC_TRUE)
            %assign ::ItJEOCFcn_%<ADC_Name>    = TLC_FALSE		
            /* Update Injected End of Conversion interrupt function */
            %<ADC_Name>_DataLink.ItJEOCFcn = %<ADC_Name>_ItJEOCFcn;
			%else
            %exit Multiple %<ADC_Name> ADC_Read block: Update Injected End of Conversion interrupt already used. 
            %endif
        %endif
        %if (ISEQUAL(AWD_IT, "on"))
            %if !EXISTS(::ItAWDFcn_%<ADC_Name>) || (::ItAWDFcn_%<ADC_Name> == TLC_TRUE)
            %assign ::ItAWDFcn_%<ADC_Name>    = TLC_FALSE		
           /* Update Analog Watchdog interrupt function */
            %<ADC_Name>_DataLink.ItAWDFcn = %<ADC_Name>_ItAWDFcn;
			%else
            %exit Multiple %<ADC_Name> ADC_Read block: Update Analog Watchdog interrupt already used. 
            %endif
        %endif
        %if (ISEQUAL(OVR_IT, "on"))
            %if !EXISTS(::ItOVRFcn_%<ADC_Name>) || (::ItOVRFcn_%<ADC_Name> == TLC_TRUE)
            %assign ::ItOVRFcn_%<ADC_Name>    = TLC_FALSE		
            /* Update Overrun interrupt function */
            %<ADC_Name>_DataLink.ItOVRFcn = %<ADC_Name>_ItOVRFcn;
 			%else
            %exit Multiple %<ADC_Name> ADC_Read block: Update Overrun interrupt already used. 
            %endif
        %endif		
        %closefile ADC_Buf
		%<LibMdlStartCustomCode(ADC_Buf,"execution")>;
		
    %endfunction


%% Code for ADC configuration call:
    %function BlockInstanceSetup(block, system) void
        %%model.c and model.h files
        %assign SrcBaseName = LibGetMdlSrcBaseName()
        %assign modelH      = LibCreateSourceFile("Header", "Simulink", SrcBaseName)
        %assign modelC      = LibCreateSourceFile("Source", "Simulink", SrcBaseName)
        %%model_ADC.h and model_ADC.c files
        %assign SrcBaseName_ADC = "%<SrcBaseName>_ADC"
        %assign modelH_ADC      = LibCreateSourceFile("Header", "Simulink", SrcBaseName_ADC)
        %assign modelC_ADC      = LibCreateSourceFile("Source", "Simulink", SrcBaseName_ADC)
%%Include model.h to model_ADC.c 
        %if EXISTS(::InsertIncludesToADC) && (::InsertIncludesToADC == TLC_TRUE)
            %assign ::InsertIncludesToADC    = TLC_FALSE		
            %openfile ADC_Buf
				#include "%<SrcBaseName>.h"
				#include "%<SrcBaseName_ADC>.h"
            %closefile ADC_Buf
            %<LibSetSourceFileSection(modelC_ADC,"Includes",ADC_Buf)>
        %endif
%%AND Include model_ADC.h to model.c
        %if EXISTS(::InsertIncludesFromADC) && (::InsertIncludesFromADC == TLC_TRUE)
            %assign ::InsertIncludesFromADC    = TLC_FALSE		
            %openfile ADC_Buf
				#include "%<SrcBaseName_ADC>.h"
            %closefile ADC_Buf
            %<LibSetSourceFileSection(modelH,"Includes",ADC_Buf)>
            
			%openfile ADC_Buf
				//RP MODIF #include "%<SrcBaseName>_STM32.h"
				#include "STM32_Config.h"
            %closefile ADC_Buf
            %<LibSetSourceFileSection(modelH_ADC,"Includes",ADC_Buf)>						
        %endif

%%Then build model_ADC.h and model_ADC.c
        %assign ADC_Name =  SFcnParamSettings.ADC_Name
        %assign NbADC =  SFcnParamSettings.NbADC
		%assign DmaReq = SFcnParamSettings.DmaReq
		%assign ItReq = SFcnParamSettings.ItReq
		%assign ADC_RegNb = SFcnParamSettings.ADC_RegNb
		%assign ADC_InjNb = SFcnParamSettings.ADC_InjNb
		%assign ADC_NbTotCh = %<ADC_RegNb> + %<ADC_InjNb>
		%assign adcNum = IDNUM("%<ADC_Name>")[1]

		%assign AWD_Mode = SFcnParamSettings.AWD_Mode
		%assign AWD_Ch = SFcnParamSettings.AWD_Ch
		%assign AWD_HThres = SFcnParamSettings.AWD_HThres
		%assign AWD_LThres = SFcnParamSettings.AWD_LThres
		%assign AWD_En_Int = SFcnParamSettings.AWD_En_Int
		%assign EOC_SEQ = SFcnParamSettings.EOC_SEQ
		%assign EOC_IT = SFcnParamSettings.EOC_IT
		%assign JEOC_IT = SFcnParamSettings.JEOC_IT
		%assign AWD_IT = SFcnParamSettings.AWD_IT
		%assign OVR_IT = SFcnParamSettings.OVR_IT


		
%%warning "---------->ADC_Name: %<ADC_Name> NbADC:%<NbADC>"
		
		
%% Code for required ADC external definition: in model_ADC.c file
		%assign adcNum = IDNUM("%<ADC_Name>")[1]

    
    %if EXISTS(::InsertADC) && (::InsertADC == TLC_TRUE)
            %assign ::InsertADC    = TLC_FALSE		
            %openfile ADC_Buf
			/** 
			* @brief  ADC data information
			*/ 
			typedef struct 	{
			 uint16_t*                RegularValueBuffer;     /*!< Regular buffer for converted value*/
			 uint16_t*                InjectedValueBuffer;    /*!< Injected buffer for converted value*/
			 uint32_t                 RegularCurrentRank;     /*!< Regular current rank*/
			 uint32_t                 InjectedCurrentRank;    /*!< Injected current rank*/
			 uint32_t				  nbRegChannel;			  /*!< Number of regular channel*/
			 uint32_t				  nbInjChannel;			  /*!< Number of injected channel*/
			 uint8_t 				  useDMA;				  /*!< DMA aquisition mode */
			 uint8_t                  IntEndOfAllConv;        /*!< EOS/JEOS Int at end of all conversions */
             void (* ItEOCFcn)(void);  
             void (* ItJEOCFcn)(void);  
             void (* ItAWDFcn)(void);  
             void (* ItOVRFcn)(void);  
			}ADC_DataLinkTypeDef;	
 			%if (%<NbADC> > 1)
			extern uint16_t G_NbAdcConf; /* Number of ADC configured */
            /* Array of ADC data information */
            extern ADC_DataLinkTypeDef*  G_ADC_Data[%<NbADC>];
			extern ADC_HandleTypeDef*  G_ADC_Handler[%<NbADC>];
			%else
            extern ADC_DataLinkTypeDef*   G_ADC_Data;      /* Pointer to ADC data information*/
			extern ADC_HandleTypeDef*     G_ADC_Handler;   /* Pointer to ADC handler */
			%endif
            %closefile ADC_Buf
            %<LibSetSourceFileSection(modelH_ADC,"Defines",ADC_Buf)>
           
  		    %openfile ADC_Buf
 			%if (%<NbADC> > 1)
			uint16_t               G_NbAdcConf = 0; /* Number of ADC configured */
            /* Array of ADC data information */
            ADC_DataLinkTypeDef*   G_ADC_Data[%<NbADC>];
			ADC_HandleTypeDef*     G_ADC_Handler[%<NbADC>];
			%else
            ADC_DataLinkTypeDef*   G_ADC_Data;      /* Pointer to ADC data information*/
			ADC_HandleTypeDef*     G_ADC_Handler;   /* Pointer to ADC handler */
			%endif
            %closefile ADC_Buf
            %<LibSetSourceFileSection(modelC_ADC,"Defines",ADC_Buf)>
	%endif
	
	
	%if !EXISTS(::VarDef_%<ADC_Name>) || (::VarDef_%<ADC_Name> == TLC_TRUE)
        %assign ::VarDef_%<ADC_Name>    = TLC_FALSE		
        %openfile ADC_Buf
            /* %<ADC_Name> handler */
            extern ADC_HandleTypeDef hadc%<adcNum>;
            %%test for DMA handler
            %if (ISEQUAL(DmaReq, "on"))
            extern DMA_HandleTypeDef hdma_adc%<adcNum>;
            %endif
        %closefile ADC_Buf
        %<LibSetSourceFileSection(modelH_ADC,"Defines",ADC_Buf)>

%%Buffer for Regular channels creation
        %if (%<ADC_RegNb> > 0)
        %openfile ADC_Buf
        /* %<ADC_Name> Regular channel Converted value buffer */
        uint16_t %<ADC_Name>_RegularConvertedValue[%<ADC_RegNb>];
        %closefile ADC_Buf
        %<LibSetSourceFileSection(modelC_ADC,"Defines",ADC_Buf)>
        %openfile ADC_Buf
        /* %<ADC_Name> Regular channel Converted value buffer */
        extern uint16_t %<ADC_Name>_RegularConvertedValue[%<ADC_RegNb>];
        %closefile ADC_Buf
        %<LibSetSourceFileSection(modelH_ADC,"Defines",ADC_Buf)>
        %endif

%%Buffer for Injected channels creation
        %if (%<ADC_InjNb> > 0)
		%if (ISEQUAL(DmaReq, "on")||ISEQUAL(ItReq, "on"))		
        %openfile ADC_Buf
       /* %<ADC_Name> Injected channel Converted value buffer */
        uint16_t %<ADC_Name>_InjectedConvertedValue[%<ADC_InjNb>];
        %closefile ADC_Buf
        %<LibSetSourceFileSection(modelC_ADC,"Defines",ADC_Buf)>
        %openfile ADC_Buf
       /* %<ADC_Name> Injected channel Converted value buffer */
        extern uint16_t %<ADC_Name>_InjectedConvertedValue[%<ADC_InjNb>];
        %closefile ADC_Buf
        %<LibSetSourceFileSection(modelH_ADC,"Defines",ADC_Buf)>
        %endif
        %endif

        %openfile ADC_Buf
		/* %<ADC_Name> data information*/
		ADC_DataLinkTypeDef  %<ADC_Name>_DataLink;					
        %if (ISEQUAL(ItReq, "on") == TLC_FALSE && ISEQUAL(DmaReq, "on") == TLC_FALSE)
		/* %<ADC_Name> polling timeout value. Number of Solver loop. (can be changed)*/
		uint32_t G_%<ADC_Name>_PollTimeOut = 10;
		%endif		
        %closefile ADC_Buf
        %<LibSetSourceFileSection(modelC_ADC,"Defines",ADC_Buf)>

        %openfile ADC_Buf
    	/* %<ADC_Name> data information*/
        extern ADC_DataLinkTypeDef  %<ADC_Name>_DataLink;
        %if (ISEQUAL(ItReq, "on") == TLC_FALSE && ISEQUAL(DmaReq, "on") == TLC_FALSE)
		/* %<ADC_Name> polling timeout value. Number of Solver loop. (can be changed)*/
		extern uint32_t G_%<ADC_Name>_PollTimeOut;
		%endif		
        %closefile ADC_Buf
        %<LibSetSourceFileSection(modelH_ADC,"Defines",ADC_Buf)>
	%endif
			
            %%Callback function for IT conversion
            %if (ISEQUAL(ItReq, "on") || ISEQUAL(DmaReq, "on"))
            %%For regular channels
            %if (%<ADC_RegNb> > 0)
            %if EXISTS(::InsertItRegADC) && (::InsertItRegADC == TLC_TRUE)
            %assign ::InsertItRegADC    = TLC_FALSE				
            %openfile ADC_Buf
            /*******************************************************************************
            * Function Name  : HAL_ADC_ConvCpltCallback
            * Description    : Regular interrupt conversion complete callback 
            * Input          : ADC_HandleTypeDef*
            *******************************************************************************/
            void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* AdcHandle)
            {
			%if(%<NbADC> > 1)				
				uint16_t L_AdcHandleIdx = 0;/* Index to retreive ADC data information */
    			ADC_DataLinkTypeDef*   pL_ADC_Data = G_ADC_Data[0]; /* Pt to the list of ADC data information */
				ADC_HandleTypeDef*     pL_ADC_Handler = G_ADC_Handler[0]; /* Pt to the list of ADC handler */
				for(L_AdcHandleIdx = 0;L_AdcHandleIdx < %<NbADC>;L_AdcHandleIdx++) {
					pL_ADC_Handler = G_ADC_Handler[L_AdcHandleIdx];
					if(pL_ADC_Handler == AdcHandle) {
						pL_ADC_Data = G_ADC_Data[L_AdcHandleIdx];
						break;
					}
				}
			%else
    			ADC_DataLinkTypeDef*   pL_ADC_Data = G_ADC_Data; /* Pt to ADC data information */
				ADC_HandleTypeDef*     pL_ADC_Handler = G_ADC_Handler; /* Pt to ADC handler */
			%endif
				if(pL_ADC_Handler == AdcHandle) {					
					if(pL_ADC_Data->useDMA == false) {
					/* Process It for current received channel */
						/* Store converted value of current regular channel */
						pL_ADC_Data->RegularValueBuffer[pL_ADC_Data->RegularCurrentRank] = HAL_ADC_GetValue(AdcHandle);   					
						/*Increment rank for next conversion*/
						pL_ADC_Data->RegularCurrentRank++;
						/* Test for max conversion channel number */
						if(pL_ADC_Data->RegularCurrentRank >= pL_ADC_Data->nbRegChannel){
							pL_ADC_Data->RegularCurrentRank = 0;
						}	    
					}
					if(pL_ADC_Data->ItEOCFcn != NULL){
                        /* Call End Of Conversion function */
                        pL_ADC_Data->ItEOCFcn();
                    }
				}
            }       
            %closefile ADC_Buf
            %<LibSetSourceFileSection(modelC_ADC,"Functions",ADC_Buf)>			
            %endif        
			%endif
            %%For injected channels
            %if (%<ADC_InjNb> > 0)
        	%if EXISTS(::InsertItInjADC) && (::InsertItInjADC == TLC_TRUE)
            %assign ::InsertItInjADC    = TLC_FALSE	
            %openfile ADC_Buf
            /*******************************************************************************
            * Function Name  : HAL_ADCEx_InjectedConvCpltCallback
            * Description    : Injected interrupt conversion complete callback 
            * Input          : ADC_HandleTypeDef*
            *******************************************************************************/
            void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* AdcHandle)
            {				
				uint16_t  L_InjChannel; /*Current injected channel*/
			%if(%<NbADC> > 1)				
				uint16_t L_AdcHandleIdx = 0;/* Index to retreive ADC data information */
    			ADC_DataLinkTypeDef*   pL_ADC_Data = G_ADC_Data[0]; /* Pt to the list of ADC data information */
				ADC_HandleTypeDef*     pL_ADC_Handler = G_ADC_Handler[0]; /* Pt to the list of ADC handler */
				for(L_AdcHandleIdx = 0;L_AdcHandleIdx < %<NbADC>;L_AdcHandleIdx++) {
					pL_ADC_Handler = G_ADC_Handler[L_AdcHandleIdx];
					if(pL_ADC_Handler == AdcHandle) {
						pL_ADC_Data = G_ADC_Data[L_AdcHandleIdx];
						break;
					}
				}
			%else
    			ADC_DataLinkTypeDef*   pL_ADC_Data = G_ADC_Data; /* Pt to ADC data information */
				ADC_HandleTypeDef*     pL_ADC_Handler = G_ADC_Handler; /* Pt to ADC handler */
			%endif
				if(pL_ADC_Handler == AdcHandle) {
					if (pL_ADC_Data->IntEndOfAllConv == true) {
						/* Store converted values for all Injected channels */
						for(L_InjChannel=ADC_INJECTED_RANK_1;L_InjChannel<=pL_ADC_Data->nbInjChannel;L_InjChannel++) {
							pL_ADC_Data->InjectedValueBuffer[L_InjChannel-1] = HAL_ADCEx_InjectedGetValue(AdcHandle, L_InjChannel);												
						}
					}else{				
						/* Store converted value of current Injected channel */					
						pL_ADC_Data->InjectedValueBuffer[pL_ADC_Data->InjectedCurrentRank] = HAL_ADCEx_InjectedGetValue(AdcHandle, pL_ADC_Data->InjectedCurrentRank);					
						/*Increment rank for next conversion*/
						pL_ADC_Data->InjectedCurrentRank++;
						/* Test for max conversion channel number */
						if(pL_ADC_Data->InjectedCurrentRank >= pL_ADC_Data->nbInjChannel){
							pL_ADC_Data->InjectedCurrentRank = ADC_INJECTED_RANK_1;
						}
					}
					if(pL_ADC_Data->ItJEOCFcn != NULL){
						/* Call Injected End Of Conversion function */
						pL_ADC_Data->ItJEOCFcn();
					}	            
				}
            }        
            %closefile ADC_Buf
            %<LibSetSourceFileSection(modelC_ADC,"Functions",ADC_Buf)>
            %endif        
            %endif   
			%endif	

        %%Callback function for AWD IT
        %if (ISEQUAL(AWD_IT, "on"))
		%if EXISTS(::InsertAwdItADC) && (::InsertAwdItADC == TLC_TRUE)
            %assign ::InsertAwdItADC     = TLC_FALSE				
            %openfile ADC_Buf
            /*******************************************************************************
            * Function Name  : HAL_ADC_LevelOutOfWindowCallback
            * Description    : Analog Watchdog window interrupt callback 
            * Input          : ADC_HandleTypeDef*
            *******************************************************************************/
            void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* AdcHandle)
            {
			%if(%<NbADC> > 1)				
				uint16_t L_AdcHandleIdx = 0;/* Index to retreive ADC data information */
    			ADC_DataLinkTypeDef*   pL_ADC_Data = G_ADC_Data[0]; /* Pt to the list of ADC data information */
				ADC_HandleTypeDef*     pL_ADC_Handler = G_ADC_Handler[0]; /* Pt to the list of ADC handler */
				for(L_AdcHandleIdx = 0;L_AdcHandleIdx < %<NbADC>;L_AdcHandleIdx++) {
					pL_ADC_Handler = G_ADC_Handler[L_AdcHandleIdx];
					if(pL_ADC_Handler == AdcHandle) {
						pL_ADC_Data = G_ADC_Data[L_AdcHandleIdx];
						break;
					}
				}
			%else
    			ADC_DataLinkTypeDef*   pL_ADC_Data = G_ADC_Data; /* Pt to ADC data information */
				ADC_HandleTypeDef*     pL_ADC_Handler = G_ADC_Handler; /* Pt to ADC handler */
			%endif
				if(pL_ADC_Handler == AdcHandle) {
					if(pL_ADC_Data->ItAWDFcn != NULL){
                        /* Call Analog Watchdog function */
                        pL_ADC_Data->ItAWDFcn();
                    }	            
				}
            }       
            %closefile ADC_Buf
            %<LibSetSourceFileSection(modelC_ADC,"Functions",ADC_Buf)>	
        %endif        
		%endif

        %%Callback function for OVR IT
        %if (ISEQUAL(OVR_IT, "on"))
		%if EXISTS(::InsertOvrItADC) && (::InsertOvrItADC == TLC_TRUE)
            %assign ::InsertOvrItADC     = TLC_FALSE				
            %openfile ADC_Buf
            /*******************************************************************************
            * Function Name  : HAL_ADC_ErrorCallback
            * Description    : overrun interrupt callback 
            * Input          : ADC_HandleTypeDef*
            *******************************************************************************/
            void HAL_ADC_ErrorCallback(ADC_HandleTypeDef* AdcHandle)
            {
			%if(%<NbADC> > 1)				
				uint16_t L_AdcHandleIdx = 0;/* Index to retreive ADC data information */
    			ADC_DataLinkTypeDef*   pL_ADC_Data = G_ADC_Data[0]; /* Pt to the list of ADC data information */
				ADC_HandleTypeDef*     pL_ADC_Handler = G_ADC_Handler[0]; /* Pt to the list of ADC handler */
				for(L_AdcHandleIdx = 0;L_AdcHandleIdx < %<NbADC>;L_AdcHandleIdx++) {
					pL_ADC_Handler = G_ADC_Handler[L_AdcHandleIdx];
					if(pL_ADC_Handler == AdcHandle) {
						pL_ADC_Data = G_ADC_Data[L_AdcHandleIdx];
						break;
					}
				}
			%else
    			ADC_DataLinkTypeDef*   pL_ADC_Data = G_ADC_Data; /* Pt to ADC data information */
				ADC_HandleTypeDef*     pL_ADC_Handler = G_ADC_Handler; /* Pt to ADC handler */
			%endif
				if(pL_ADC_Handler == AdcHandle) {
					if(pL_ADC_Data->ItOVRFcn != NULL){
                        /* Call Overrun function */
                        pL_ADC_Data->ItOVRFcn();
                    }	            
				}
            }       
            %closefile ADC_Buf
            %<LibSetSourceFileSection(modelC_ADC,"Functions",ADC_Buf)>	
        %endif        
		%endif
			
    %endfunction
%else
%% ERROR ADC INIT MUST BE CALLED ONCE ONLY 
   %trace ERROR ADC INIT MUST BE CALLED ONCE ONLY 
%endif 

%% Function: Outputs ==========================================
%% Abstract:
%% ADC_Read input value depending on pin config
%%
   %function Outputs(block, system) Output
	/* %<Type> Block: %<Name> */  
        %%model_ADC.h and model_ADC.c files
        %assign SrcBaseName = LibGetMdlSrcBaseName()
        %assign modelH      = LibCreateSourceFile("Header", "Simulink", SrcBaseName)
        %assign modelC      = LibCreateSourceFile("Source", "Simulink", SrcBaseName)
        %assign SrcBaseName_ADC = "%<SrcBaseName>_ADC"
        %assign modelH_ADC      = LibCreateSourceFile("Header", "Simulink", SrcBaseName_ADC)
        %assign modelC_ADC      = LibCreateSourceFile("Source", "Simulink", SrcBaseName_ADC)

        %assign ADC_Name =  SFcnParamSettings.ADC_Name
		%assign DmaReq = SFcnParamSettings.DmaReq
		%assign ItReq = SFcnParamSettings.ItReq
		%assign ADC_RegNb = SFcnParamSettings.ADC_RegNb
		%assign ADC_InjNb = SFcnParamSettings.ADC_InjNb
		%assign adcNum = IDNUM("%<ADC_Name>")[1]
		%assign EOC_SEQ = SFcnParamSettings.EOC_SEQ
		%assign EOC_IT = SFcnParamSettings.EOC_IT
		%assign JEOC_IT = SFcnParamSettings.JEOC_IT
		%assign AWD_IT = SFcnParamSettings.AWD_IT
		%assign OVR_IT = SFcnParamSettings.OVR_IT			
		%assign RgRk1 = SFcnParamSettings.RgRk1
		%assign RgRk2 = SFcnParamSettings.RgRk2
		%assign RgRk3 = SFcnParamSettings.RgRk3
		%assign RgRk4 = SFcnParamSettings.RgRk4
		%assign RgRk5 = SFcnParamSettings.RgRk5
		%assign RgRk6 = SFcnParamSettings.RgRk6
		%assign RgRk7 = SFcnParamSettings.RgRk7
		%assign RgRk8 = SFcnParamSettings.RgRk8
		%assign RgRk9 = SFcnParamSettings.RgRk9
		%assign RgRk10 = SFcnParamSettings.RgRk10
		%assign RgRk11 = SFcnParamSettings.RgRk11
		%assign RgRk12 = SFcnParamSettings.RgRk12
		%assign RgRk13 = SFcnParamSettings.RgRk13
		%assign RgRk14 = SFcnParamSettings.RgRk14
		%assign RgRk15 = SFcnParamSettings.RgRk15
		%assign RgRk16 = SFcnParamSettings.RgRk16
		%assign InjRk1 = SFcnParamSettings.InjRk1
		%assign InjRk2 = SFcnParamSettings.InjRk2
		%assign InjRk3 = SFcnParamSettings.InjRk3
		%assign InjRk4 = SFcnParamSettings.InjRk4
			
 	    %assign OutputNum = 0
        %assign  chOffset = 0

        %if (ISEQUAL(EOC_IT, "on") || ISEQUAL(JEOC_IT, "on") || ISEQUAL(AWD_IT, "on") || ISEQUAL(OVR_IT, "on"))
        %assign OutputNum = 1
        %endif

        %%%%%%%% VERY IMPORTANT %%%%%%%%%
        %%%  DO NOT CHANGE INTERRUPT  %%%
        %%%     FUNCTION ORDER        %%%
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

        %if (ISEQUAL(EOC_IT, "on"))
            %openfile ADC_Buf
			/* %<ADC_Name> Regular End Of Convertion IT function */
            void %<ADC_Name>_ItEOCFcn(void);
            %closefile ADC_Buf
            %<LibSetSourceFileSection(modelH_ADC,"Defines",ADC_Buf)>
			
			%assign chartIsFound = 0
            %openfile ADC_Buf
            /*******************************************************************************
            * Function Name  : %<ADC_Name>_ItEOCFcn
            * Description    : %<ADC_Name> End of Conversion interrupt
            * Input          : None
            *******************************************************************************/
            void %<ADC_Name>_ItEOCFcn()
            {
                    %foreach callIdx = NumSFcnSysOutputCalls
                        %if (ISEQUAL(callIdx, %<chOffset>))	
                            %if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall,"unconnected")
                                %assign wrnTxt = "No code will be generated for EOC IRQ  "\
                                "since it is not connected to a system."
                                %<LibReportWarning(wrnTxt)>
                                %continue
                            %endif
							%%Is it connected to model including Chart
							%assign chartIsFound = FunctionCalledAsChart(callIdx)							
                            %% call the downstream system
                            %<LibBlockExecuteFcnCall(block, callIdx)>\
                    	%endif
                    %endforeach
            }
            %closefile ADC_Buf					
			%if (chartIsFound == 1)
				%<LibSetSourceFileSection(modelC,"Functions",ADC_Buf)>	
			%else
				%<LibSetSourceFileSection(modelC_ADC,"Functions",ADC_Buf)>	
			%endif
			%%Then inc channel num for next IT connection
			%assign  chOffset = %<chOffset> + 1								
        %endif		
		
        %if (ISEQUAL(JEOC_IT, "on"))
            %openfile ADC_Buf
			/* %<ADC_Name> Injected End Of Convertion IT function */
            void %<ADC_Name>_ItJEOCFcn(void);
            %closefile ADC_Buf
            %<LibSetSourceFileSection(modelH_ADC,"Defines",ADC_Buf)>

 			%assign chartIsFound = 0
            %openfile ADC_Buf
            /*******************************************************************************
            * Function Name  : %<ADC_Name>_ItJEOCFcn
            * Description    : %<ADC_Name> Injected End of Conversion interrupt
            * Input          : None
            *******************************************************************************/
            void %<ADC_Name>_ItJEOCFcn()
            {
                    %foreach callIdx = NumSFcnSysOutputCalls
                        %if (ISEQUAL(callIdx, %<chOffset>))	
                            %if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall,"unconnected")
                        		%assign wrnTxt = "No code will be generated for JEOC IRQ  "\
                                "since it is not connected to a system."
                                %<LibReportWarning(wrnTxt)>
                                %continue
                            %endif
							%%Is it connected to model including Chart
							%assign chartIsFound = FunctionCalledAsChart(callIdx)							
                            %% call the downstream system
                            %<LibBlockExecuteFcnCall(block, callIdx)>\
                    	%endif
                    %endforeach
            }
            %closefile ADC_Buf					
			%if (chartIsFound == 1)
				%<LibSetSourceFileSection(modelC,"Functions",ADC_Buf)>	
			%else
				%<LibSetSourceFileSection(modelC_ADC,"Functions",ADC_Buf)>	
			%endif
			%%Then inc channel num for next IT connection
			%assign  chOffset = %<chOffset> + 1								
        %endif


        %if (ISEQUAL(AWD_IT, "on"))
            %openfile ADC_Buf
			/* %<ADC_Name> Analog Watchdog IT function */
            void %<ADC_Name>_ItAWDFcn(void);
            %closefile ADC_Buf
            %<LibSetSourceFileSection(modelH_ADC,"Defines",ADC_Buf)>

 			%assign chartIsFound = 0
            %openfile ADC_Buf
            /*******************************************************************************
            * Function Name  : %<ADC_Name>_ItAWDFcn
            * Description    : %<ADC_Name> Analog Watchdog interrupt
            * Input          : None
            *******************************************************************************/
            void %<ADC_Name>_ItAWDFcn()
            {
                    %foreach callIdx = NumSFcnSysOutputCalls
                        %if (ISEQUAL(callIdx, %<chOffset>))	
                            %if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall,"unconnected")
                        		%assign wrnTxt = "No code will be generated for AWD IRQ  "\
                                "since it is not connected to a system."
                                %<LibReportWarning(wrnTxt)>
                                %continue
                            %endif
							%%Is it connected to model including Chart
							%assign chartIsFound = FunctionCalledAsChart(callIdx)							
                            %% call the downstream system
                            %<LibBlockExecuteFcnCall(block, callIdx)>\
                    	%endif
                    %endforeach
            }
            %closefile ADC_Buf					
			%if (chartIsFound == 1)
				%<LibSetSourceFileSection(modelC,"Functions",ADC_Buf)>	
			%else
				%<LibSetSourceFileSection(modelC_ADC,"Functions",ADC_Buf)>	
			%endif
			%%Then inc channel num for next IT connection
			%assign  chOffset = %<chOffset> + 1								
        %endif

        %if (ISEQUAL(OVR_IT, "on"))
            %openfile ADC_Buf
			/* %<ADC_Name> Over run IT function */
            void %<ADC_Name>_ItOVRFcn(void);
            %closefile ADC_Buf
            %<LibSetSourceFileSection(modelH_ADC,"Defines",ADC_Buf)>

 			%assign chartIsFound = 0
            %openfile ADC_Buf
            /*******************************************************************************
            * Function Name  : %<ADC_Name>_ItOVRFcn
            * Description    : %<ADC_Name> Overrun interrupt
            * Input          : None
            *******************************************************************************/
            void %<ADC_Name>_ItOVRFcn()
            {
                    %foreach callIdx = NumSFcnSysOutputCalls
                        %if (ISEQUAL(callIdx, %<chOffset>))	
                            %if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall,"unconnected")
                        		%assign wrnTxt = "No code will be generated for OVR IRQ  "\
                                "since it is not connected to a system."
                                %<LibReportWarning(wrnTxt)>
                                %continue
                            %endif
							%%Is it connected to model including Chart
							%assign chartIsFound = FunctionCalledAsChart(callIdx)							
                            %% call the downstream system
                            %<LibBlockExecuteFcnCall(block, callIdx)>\
                    	%endif
                    %endforeach
            }
            %closefile ADC_Buf					
			%if (chartIsFound == 1)
				%<LibSetSourceFileSection(modelC,"Functions",ADC_Buf)>	
			%else
				%<LibSetSourceFileSection(modelC_ADC,"Functions",ADC_Buf)>	
			%endif
			%%Then inc channel num for next IT connection
			%assign  chOffset = %<chOffset> + 1								
        %endif

%%  Process output values
		%if (ISEQUAL(DmaReq, "off")&&ISEQUAL(ItReq, "off"))		
		%if (%<ADC_RegNb> > 0 )
		/* Read regular %<ADC_Name> value */
		for(uint16_t i=0;i<%<ADC_RegNb>;i++)
		if(HAL_ADC_PollForConversion(&hadc%<adcNum>, G_%<ADC_Name>_PollTimeOut) == HAL_OK) {
			%<ADC_Name>_RegularConvertedValue[i] = (uint16_t)HAL_ADC_GetValue(&hadc%<adcNum>);
		}			
        %endif	
		%endif

		%if (ISEQUAL(RgRk1, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank1 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[0];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk2, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank2 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[1];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk3, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank3 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[2];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk4, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank4 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[3];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk5, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank5 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[4];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk6, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank6 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[5];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk7, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank7 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[6];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk8, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank8 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[7];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk9, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank9 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[8];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk10, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank10 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[9];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk11, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank11 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[10];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk12, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank12 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[11];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk13, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank13 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[12];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk14, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank14 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[13];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk15, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank15 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[14];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(RgRk16, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		/* Get regular rank16 output value from %<ADC_Name> regular value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_RegularConvertedValue[15];
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif
		
		%if (ISEQUAL(InjRk1, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		%if (ISEQUAL(DmaReq, "on")||ISEQUAL(ItReq, "on"))		
		/* Get injected rank1 output value from %<ADC_Name> injected value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_InjectedConvertedValue[0];
		%else
		/* Get injected rank1 output value */
		%<chVal> = (uint16_t)HAL_ADCEx_InjectedGetValue(&hadc%<adcNum>,ADC_INJECTED_RANK_1);
		%endif
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif
		
		%if (ISEQUAL(InjRk2, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		%if (ISEQUAL(DmaReq, "on")||ISEQUAL(ItReq, "on"))		
		/* Get injected rank2 output value from %<ADC_Name> injected value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_InjectedConvertedValue[1];
		%else
		/* Get injected rank2 output value */
		%<chVal> = (uint16_t)HAL_ADCEx_InjectedGetValue(&hadc%<adcNum>,ADC_INJECTED_RANK_2);
		%endif
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(InjRk3, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		%if (ISEQUAL(DmaReq, "on")||ISEQUAL(ItReq, "on"))		
		/* Get injected rank3 output value from %<ADC_Name> injected value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_InjectedConvertedValue[2];
		%else
		/* Get injected rank3 output value */
		%<chVal> = (uint16_t)HAL_ADCEx_InjectedGetValue(&hadc%<adcNum>,ADC_INJECTED_RANK_3);
		%endif
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

		%if (ISEQUAL(InjRk4, "on"))
		%assign chVal = LibBlockOutputSignal(OutputNum, "", "", 0) 		
		%if (ISEQUAL(DmaReq, "on")||ISEQUAL(ItReq, "on"))		
		/* Get injected rank4 output value from %<ADC_Name> injected value buffer */
        %<chVal> = (uint16_t)%<ADC_Name>_InjectedConvertedValue[3];
		%else
		/* Get injected rank4 output value */
		%<chVal> = (uint16_t)HAL_ADCEx_InjectedGetValue(&hadc%<adcNum>,ADC_INJECTED_RANK_4);
		%endif
 	    %assign  OutputNum = %<OutputNum> + 1 	
        %endif

        %if (~ISEQUAL(DmaReq, "on")&& ISEQUAL(ItReq, "on"))
			%if (%<ADC_RegNb> > 0)
			/* Re-Start interrupt conversion for %<ADC_Name> regular channel*/
			HAL_ADC_Start_IT(&hadc%<adcNum>);
			%endif
			%if (%<ADC_InjNb> > 0)
			/* Re-Start interrupt conversion for %<ADC_Name> injected channel*/			
			HAL_ADCEx_InjectedStart_IT(&hadc%<adcNum>);
			%endif
		%else
		    %if (%<ADC_RegNb> > 0)
			/* Re-Start %<ADC_Name> conversion */
			HAL_ADC_Start(&hadc%<adcNum>);
 			%endif
			%if (%<ADC_InjNb> > 0)
            /* Re-Start conversion for %<ADC_Name> injected channel*/			
			HAL_ADCEx_InjectedStart(&hadc%<adcNum>);
 			%endif				
        %endif			
   %endfunction
		

%% [EOF] ADC_Read.tlc






